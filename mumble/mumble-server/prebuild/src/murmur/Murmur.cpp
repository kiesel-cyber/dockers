//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.3
//
// <auto-generated>
//
// Generated from file `Murmur.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Murmur.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <Ice/LocalException.h>
#include <Ice/SliceChecksums.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 3
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Murmur::Tree> iceC_Murmur_Tree_init("::Murmur::Tree");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::MurmurException> iceC_Murmur_MurmurException_init("::Murmur::MurmurException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::InvalidSessionException> iceC_Murmur_InvalidSessionException_init("::Murmur::InvalidSessionException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::InvalidChannelException> iceC_Murmur_InvalidChannelException_init("::Murmur::InvalidChannelException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::InvalidServerException> iceC_Murmur_InvalidServerException_init("::Murmur::InvalidServerException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::ServerBootedException> iceC_Murmur_ServerBootedException_init("::Murmur::ServerBootedException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::ServerFailureException> iceC_Murmur_ServerFailureException_init("::Murmur::ServerFailureException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::InvalidUserException> iceC_Murmur_InvalidUserException_init("::Murmur::InvalidUserException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::InvalidTextureException> iceC_Murmur_InvalidTextureException_init("::Murmur::InvalidTextureException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::InvalidCallbackException> iceC_Murmur_InvalidCallbackException_init("::Murmur::InvalidCallbackException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::InvalidSecretException> iceC_Murmur_InvalidSecretException_init("::Murmur::InvalidSecretException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::NestingLimitException> iceC_Murmur_NestingLimitException_init("::Murmur::NestingLimitException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::WriteOnlyException> iceC_Murmur_WriteOnlyException_init("::Murmur::WriteOnlyException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Murmur::InvalidInputDataException> iceC_Murmur_InvalidInputDataException_init("::Murmur::InvalidInputDataException");

const ::std::string iceC_Murmur_ServerCallback_ids[2] =
{
    "::Ice::Object",
    "::Murmur::ServerCallback"
};
const ::std::string iceC_Murmur_ServerCallback_ops[] =
{
    "channelCreated",
    "channelRemoved",
    "channelStateChanged",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "userConnected",
    "userDisconnected",
    "userStateChanged",
    "userTextMessage"
};
const ::std::string iceC_Murmur_ServerCallback_userConnected_name = "userConnected";
const ::std::string iceC_Murmur_ServerCallback_userDisconnected_name = "userDisconnected";
const ::std::string iceC_Murmur_ServerCallback_userStateChanged_name = "userStateChanged";
const ::std::string iceC_Murmur_ServerCallback_userTextMessage_name = "userTextMessage";
const ::std::string iceC_Murmur_ServerCallback_channelCreated_name = "channelCreated";
const ::std::string iceC_Murmur_ServerCallback_channelRemoved_name = "channelRemoved";
const ::std::string iceC_Murmur_ServerCallback_channelStateChanged_name = "channelStateChanged";

const ::std::string iceC_Murmur_ServerContextCallback_ids[2] =
{
    "::Ice::Object",
    "::Murmur::ServerContextCallback"
};
const ::std::string iceC_Murmur_ServerContextCallback_ops[] =
{
    "contextAction",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Murmur_ServerContextCallback_contextAction_name = "contextAction";

const ::std::string iceC_Murmur_ServerAuthenticator_ids[2] =
{
    "::Ice::Object",
    "::Murmur::ServerAuthenticator"
};
const ::std::string iceC_Murmur_ServerAuthenticator_ops[] =
{
    "authenticate",
    "getInfo",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "idToName",
    "idToTexture",
    "nameToId"
};
const ::std::string iceC_Murmur_ServerAuthenticator_authenticate_name = "authenticate";
const ::std::string iceC_Murmur_ServerAuthenticator_getInfo_name = "getInfo";
const ::std::string iceC_Murmur_ServerAuthenticator_nameToId_name = "nameToId";
const ::std::string iceC_Murmur_ServerAuthenticator_idToName_name = "idToName";
const ::std::string iceC_Murmur_ServerAuthenticator_idToTexture_name = "idToTexture";

const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_ids[3] =
{
    "::Ice::Object",
    "::Murmur::ServerAuthenticator",
    "::Murmur::ServerUpdatingAuthenticator"
};
const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_ops[] =
{
    "authenticate",
    "getInfo",
    "getRegisteredUsers",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "idToName",
    "idToTexture",
    "nameToId",
    "registerUser",
    "setInfo",
    "setTexture",
    "unregisterUser"
};
const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_registerUser_name = "registerUser";
const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_unregisterUser_name = "unregisterUser";
const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_getRegisteredUsers_name = "getRegisteredUsers";
const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_setInfo_name = "setInfo";
const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_setTexture_name = "setTexture";

const ::std::string iceC_Murmur_Server_ids[2] =
{
    "::Ice::Object",
    "::Murmur::Server"
};
const ::std::string iceC_Murmur_Server_ops[] =
{
    "addCallback",
    "addChannel",
    "addContextCallback",
    "addUserToGroup",
    "delete",
    "effectivePermissions",
    "getACL",
    "getAllConf",
    "getBans",
    "getCertificateList",
    "getChannelState",
    "getChannels",
    "getConf",
    "getListeningChannels",
    "getListeningUsers",
    "getLog",
    "getLogLen",
    "getRegisteredUsers",
    "getRegistration",
    "getState",
    "getTexture",
    "getTree",
    "getUptime",
    "getUserIds",
    "getUserNames",
    "getUsers",
    "hasPermission",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "id",
    "isListening",
    "isRunning",
    "kickUser",
    "redirectWhisperGroup",
    "registerUser",
    "removeCallback",
    "removeChannel",
    "removeContextCallback",
    "removeUserFromGroup",
    "sendMessage",
    "sendMessageChannel",
    "sendWelcomeMessage",
    "setACL",
    "setAuthenticator",
    "setBans",
    "setChannelState",
    "setConf",
    "setState",
    "setSuperuserPassword",
    "setTexture",
    "start",
    "startListening",
    "stop",
    "stopListening",
    "unregisterUser",
    "updateCertificate",
    "updateRegistration",
    "verifyPassword"
};
const ::std::string iceC_Murmur_Server_isRunning_name = "isRunning";
const ::std::string iceC_Murmur_Server_start_name = "start";
const ::std::string iceC_Murmur_Server_stop_name = "stop";
const ::std::string iceC_Murmur_Server_delete_name = "delete";
const ::std::string iceC_Murmur_Server_id_name = "id";
const ::std::string iceC_Murmur_Server_addCallback_name = "addCallback";
const ::std::string iceC_Murmur_Server_removeCallback_name = "removeCallback";
const ::std::string iceC_Murmur_Server_setAuthenticator_name = "setAuthenticator";
const ::std::string iceC_Murmur_Server_getConf_name = "getConf";
const ::std::string iceC_Murmur_Server_getAllConf_name = "getAllConf";
const ::std::string iceC_Murmur_Server_setConf_name = "setConf";
const ::std::string iceC_Murmur_Server_setSuperuserPassword_name = "setSuperuserPassword";
const ::std::string iceC_Murmur_Server_getLog_name = "getLog";
const ::std::string iceC_Murmur_Server_getLogLen_name = "getLogLen";
const ::std::string iceC_Murmur_Server_getUsers_name = "getUsers";
const ::std::string iceC_Murmur_Server_getChannels_name = "getChannels";
const ::std::string iceC_Murmur_Server_getCertificateList_name = "getCertificateList";
const ::std::string iceC_Murmur_Server_getTree_name = "getTree";
const ::std::string iceC_Murmur_Server_getBans_name = "getBans";
const ::std::string iceC_Murmur_Server_setBans_name = "setBans";
const ::std::string iceC_Murmur_Server_kickUser_name = "kickUser";
const ::std::string iceC_Murmur_Server_getState_name = "getState";
const ::std::string iceC_Murmur_Server_setState_name = "setState";
const ::std::string iceC_Murmur_Server_sendMessage_name = "sendMessage";
const ::std::string iceC_Murmur_Server_hasPermission_name = "hasPermission";
const ::std::string iceC_Murmur_Server_effectivePermissions_name = "effectivePermissions";
const ::std::string iceC_Murmur_Server_addContextCallback_name = "addContextCallback";
const ::std::string iceC_Murmur_Server_removeContextCallback_name = "removeContextCallback";
const ::std::string iceC_Murmur_Server_getChannelState_name = "getChannelState";
const ::std::string iceC_Murmur_Server_setChannelState_name = "setChannelState";
const ::std::string iceC_Murmur_Server_removeChannel_name = "removeChannel";
const ::std::string iceC_Murmur_Server_addChannel_name = "addChannel";
const ::std::string iceC_Murmur_Server_sendMessageChannel_name = "sendMessageChannel";
const ::std::string iceC_Murmur_Server_getACL_name = "getACL";
const ::std::string iceC_Murmur_Server_setACL_name = "setACL";
const ::std::string iceC_Murmur_Server_addUserToGroup_name = "addUserToGroup";
const ::std::string iceC_Murmur_Server_removeUserFromGroup_name = "removeUserFromGroup";
const ::std::string iceC_Murmur_Server_redirectWhisperGroup_name = "redirectWhisperGroup";
const ::std::string iceC_Murmur_Server_getUserNames_name = "getUserNames";
const ::std::string iceC_Murmur_Server_getUserIds_name = "getUserIds";
const ::std::string iceC_Murmur_Server_registerUser_name = "registerUser";
const ::std::string iceC_Murmur_Server_unregisterUser_name = "unregisterUser";
const ::std::string iceC_Murmur_Server_updateRegistration_name = "updateRegistration";
const ::std::string iceC_Murmur_Server_getRegistration_name = "getRegistration";
const ::std::string iceC_Murmur_Server_getRegisteredUsers_name = "getRegisteredUsers";
const ::std::string iceC_Murmur_Server_verifyPassword_name = "verifyPassword";
const ::std::string iceC_Murmur_Server_getTexture_name = "getTexture";
const ::std::string iceC_Murmur_Server_setTexture_name = "setTexture";
const ::std::string iceC_Murmur_Server_getUptime_name = "getUptime";
const ::std::string iceC_Murmur_Server_updateCertificate_name = "updateCertificate";
const ::std::string iceC_Murmur_Server_startListening_name = "startListening";
const ::std::string iceC_Murmur_Server_stopListening_name = "stopListening";
const ::std::string iceC_Murmur_Server_isListening_name = "isListening";
const ::std::string iceC_Murmur_Server_getListeningChannels_name = "getListeningChannels";
const ::std::string iceC_Murmur_Server_getListeningUsers_name = "getListeningUsers";
const ::std::string iceC_Murmur_Server_sendWelcomeMessage_name = "sendWelcomeMessage";

const ::std::string iceC_Murmur_MetaCallback_ids[2] =
{
    "::Ice::Object",
    "::Murmur::MetaCallback"
};
const ::std::string iceC_Murmur_MetaCallback_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "started",
    "stopped"
};
const ::std::string iceC_Murmur_MetaCallback_started_name = "started";
const ::std::string iceC_Murmur_MetaCallback_stopped_name = "stopped";

const ::std::string iceC_Murmur_Meta_ids[2] =
{
    "::Ice::Object",
    "::Murmur::Meta"
};
const ::std::string iceC_Murmur_Meta_ops[] =
{
    "addCallback",
    "getAllServers",
    "getBootedServers",
    "getDefaultConf",
    "getServer",
    "getSlice",
    "getSliceChecksums",
    "getUptime",
    "getVersion",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "newServer",
    "removeCallback"
};
const ::std::string iceC_Murmur_Meta_getServer_name = "getServer";
const ::std::string iceC_Murmur_Meta_newServer_name = "newServer";
const ::std::string iceC_Murmur_Meta_getBootedServers_name = "getBootedServers";
const ::std::string iceC_Murmur_Meta_getAllServers_name = "getAllServers";
const ::std::string iceC_Murmur_Meta_getDefaultConf_name = "getDefaultConf";
const ::std::string iceC_Murmur_Meta_getVersion_name = "getVersion";
const ::std::string iceC_Murmur_Meta_addCallback_name = "addCallback";
const ::std::string iceC_Murmur_Meta_removeCallback_name = "removeCallback";
const ::std::string iceC_Murmur_Meta_getUptime_name = "getUptime";
const ::std::string iceC_Murmur_Meta_getSlice_name = "getSlice";
const ::std::string iceC_Murmur_Meta_getSliceChecksums_name = "getSliceChecksums";

}

Murmur::MurmurException::~MurmurException()
{
}

const ::std::string&
Murmur::MurmurException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::MurmurException";
    return typeId;
}

Murmur::InvalidSessionException::~InvalidSessionException()
{
}

const ::std::string&
Murmur::InvalidSessionException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::InvalidSessionException";
    return typeId;
}

Murmur::InvalidChannelException::~InvalidChannelException()
{
}

const ::std::string&
Murmur::InvalidChannelException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::InvalidChannelException";
    return typeId;
}

Murmur::InvalidServerException::~InvalidServerException()
{
}

const ::std::string&
Murmur::InvalidServerException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::InvalidServerException";
    return typeId;
}

Murmur::ServerBootedException::~ServerBootedException()
{
}

const ::std::string&
Murmur::ServerBootedException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::ServerBootedException";
    return typeId;
}

Murmur::ServerFailureException::~ServerFailureException()
{
}

const ::std::string&
Murmur::ServerFailureException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::ServerFailureException";
    return typeId;
}

Murmur::InvalidUserException::~InvalidUserException()
{
}

const ::std::string&
Murmur::InvalidUserException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::InvalidUserException";
    return typeId;
}

Murmur::InvalidTextureException::~InvalidTextureException()
{
}

const ::std::string&
Murmur::InvalidTextureException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::InvalidTextureException";
    return typeId;
}

Murmur::InvalidCallbackException::~InvalidCallbackException()
{
}

const ::std::string&
Murmur::InvalidCallbackException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::InvalidCallbackException";
    return typeId;
}

Murmur::InvalidSecretException::~InvalidSecretException()
{
}

const ::std::string&
Murmur::InvalidSecretException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::InvalidSecretException";
    return typeId;
}

Murmur::NestingLimitException::~NestingLimitException()
{
}

const ::std::string&
Murmur::NestingLimitException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::NestingLimitException";
    return typeId;
}

Murmur::WriteOnlyException::~WriteOnlyException()
{
}

const ::std::string&
Murmur::WriteOnlyException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::WriteOnlyException";
    return typeId;
}

Murmur::InvalidInputDataException::~InvalidInputDataException()
{
}

const ::std::string&
Murmur::InvalidInputDataException::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::InvalidInputDataException";
    return typeId;
}

bool
Murmur::ServerCallback::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_ServerCallback_ids, iceC_Murmur_ServerCallback_ids + 2, s);
}

::std::vector<::std::string>
Murmur::ServerCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Murmur_ServerCallback_ids[0], &iceC_Murmur_ServerCallback_ids[2]);
}

::std::string
Murmur::ServerCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::ServerCallback::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::ServerCallback";
    return typeId;
}

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_userConnected(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    User iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->userConnected(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_userDisconnected(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    User iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->userDisconnected(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_userStateChanged(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    User iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->userStateChanged(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_userTextMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    User iceP_state;
    TextMessage iceP_message;
    istr->readAll(iceP_state, iceP_message);
    inS.endReadParams();
    this->userTextMessage(::std::move(iceP_state), ::std::move(iceP_message), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_channelCreated(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    Channel iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->channelCreated(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_channelRemoved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    Channel iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->channelRemoved(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_channelStateChanged(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    Channel iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->channelStateChanged(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_ServerCallback_ops, iceC_Murmur_ServerCallback_ops + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_ServerCallback_ops)
    {
        case 0:
        {
            return _iceD_channelCreated(in, current);
        }
        case 1:
        {
            return _iceD_channelRemoved(in, current);
        }
        case 2:
        {
            return _iceD_channelStateChanged(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_userConnected(in, current);
        }
        case 8:
        {
            return _iceD_userDisconnected(in, current);
        }
        case 9:
        {
            return _iceD_userStateChanged(in, current);
        }
        case 10:
        {
            return _iceD_userTextMessage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Murmur::ServerContextCallback::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_ServerContextCallback_ids, iceC_Murmur_ServerContextCallback_ids + 2, s);
}

::std::vector<::std::string>
Murmur::ServerContextCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Murmur_ServerContextCallback_ids[0], &iceC_Murmur_ServerContextCallback_ids[2]);
}

::std::string
Murmur::ServerContextCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::ServerContextCallback::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::ServerContextCallback";
    return typeId;
}

/// \cond INTERNAL
bool
Murmur::ServerContextCallback::_iceD_contextAction(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_action;
    User iceP_usr;
    int iceP_session;
    int iceP_channelid;
    istr->readAll(iceP_action, iceP_usr, iceP_session, iceP_channelid);
    inS.endReadParams();
    this->contextAction(::std::move(iceP_action), ::std::move(iceP_usr), iceP_session, iceP_channelid, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerContextCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_ServerContextCallback_ops, iceC_Murmur_ServerContextCallback_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_ServerContextCallback_ops)
    {
        case 0:
        {
            return _iceD_contextAction(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Murmur::ServerAuthenticator::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_ServerAuthenticator_ids, iceC_Murmur_ServerAuthenticator_ids + 2, s);
}

::std::vector<::std::string>
Murmur::ServerAuthenticator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Murmur_ServerAuthenticator_ids[0], &iceC_Murmur_ServerAuthenticator_ids[2]);
}

::std::string
Murmur::ServerAuthenticator::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::ServerAuthenticator::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::ServerAuthenticator";
    return typeId;
}

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceD_authenticate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_pw;
    CertificateList iceP_certificates;
    ::std::string iceP_certhash;
    bool iceP_certstrong;
    istr->readAll(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong);
    inS.endReadParams();
    ::std::string iceP_newname;
    GroupNameList iceP_groups;
    int ret = this->authenticate(::std::move(iceP_name), ::std::move(iceP_pw), ::std::move(iceP_certificates), ::std::move(iceP_certhash), iceP_certstrong, iceP_newname, iceP_groups, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_newname, iceP_groups, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceD_getInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    UserInfoMap iceP_info;
    bool ret = this->getInfo(iceP_id, iceP_info, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_info, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceD_nameToId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    int ret = this->nameToId(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceD_idToName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::string ret = this->idToName(iceP_id, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceD_idToTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    Texture ret = this->idToTexture(iceP_id, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_ServerAuthenticator_ops, iceC_Murmur_ServerAuthenticator_ops + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_ServerAuthenticator_ops)
    {
        case 0:
        {
            return _iceD_authenticate(in, current);
        }
        case 1:
        {
            return _iceD_getInfo(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        case 6:
        {
            return _iceD_idToName(in, current);
        }
        case 7:
        {
            return _iceD_idToTexture(in, current);
        }
        case 8:
        {
            return _iceD_nameToId(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Murmur::ServerUpdatingAuthenticator::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_ServerUpdatingAuthenticator_ids, iceC_Murmur_ServerUpdatingAuthenticator_ids + 3, s);
}

::std::vector<::std::string>
Murmur::ServerUpdatingAuthenticator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Murmur_ServerUpdatingAuthenticator_ids[0], &iceC_Murmur_ServerUpdatingAuthenticator_ids[3]);
}

::std::string
Murmur::ServerUpdatingAuthenticator::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::ServerUpdatingAuthenticator::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::ServerUpdatingAuthenticator";
    return typeId;
}

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceD_registerUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    UserInfoMap iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    int ret = this->registerUser(::std::move(iceP_info), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceD_unregisterUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    int ret = this->unregisterUser(iceP_id, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceD_getRegisteredUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_filter;
    istr->readAll(iceP_filter);
    inS.endReadParams();
    NameMap ret = this->getRegisteredUsers(::std::move(iceP_filter), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceD_setInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    UserInfoMap iceP_info;
    istr->readAll(iceP_id, iceP_info);
    inS.endReadParams();
    int ret = this->setInfo(iceP_id, ::std::move(iceP_info), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceD_setTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    Texture iceP_tex;
    istr->readAll(iceP_id, iceP_tex);
    inS.endReadParams();
    int ret = this->setTexture(iceP_id, ::std::move(iceP_tex), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_ServerUpdatingAuthenticator_ops, iceC_Murmur_ServerUpdatingAuthenticator_ops + 14, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_ServerUpdatingAuthenticator_ops)
    {
        case 0:
        {
            return _iceD_authenticate(in, current);
        }
        case 1:
        {
            return _iceD_getInfo(in, current);
        }
        case 2:
        {
            return _iceD_getRegisteredUsers(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_idToName(in, current);
        }
        case 8:
        {
            return _iceD_idToTexture(in, current);
        }
        case 9:
        {
            return _iceD_nameToId(in, current);
        }
        case 10:
        {
            return _iceD_registerUser(in, current);
        }
        case 11:
        {
            return _iceD_setInfo(in, current);
        }
        case 12:
        {
            return _iceD_setTexture(in, current);
        }
        case 13:
        {
            return _iceD_unregisterUser(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Murmur::Server::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_Server_ids, iceC_Murmur_Server_ids + 2, s);
}

::std::vector<::std::string>
Murmur::Server::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Murmur_Server_ids[0], &iceC_Murmur_Server_ids[2]);
}

::std::string
Murmur::Server::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::Server::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::Server";
    return typeId;
}

/// \cond INTERNAL
bool
Murmur::Server::_iceD_isRunning(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](bool ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->isRunningAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_start(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->startAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_stop(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->stopAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_delete(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->deleteAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_id(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->idAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_addCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerCallbackPrx> iceP_cb;
    istr->readAll(iceP_cb);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->addCallbackAsync(::std::move(iceP_cb), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_removeCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerCallbackPrx> iceP_cb;
    istr->readAll(iceP_cb);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->removeCallbackAsync(::std::move(iceP_cb), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setAuthenticator(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerAuthenticatorPrx> iceP_auth;
    istr->readAll(iceP_auth);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setAuthenticatorAsync(::std::move(iceP_auth), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_key;
    istr->readAll(iceP_key);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::string& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getConfAsync(::std::move(iceP_key), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getAllConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ConfigMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getAllConfAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_key;
    ::std::string iceP_value;
    istr->readAll(iceP_key, iceP_value);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setConfAsync(::std::move(iceP_key), ::std::move(iceP_value), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setSuperuserPassword(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_pw;
    istr->readAll(iceP_pw);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setSuperuserPasswordAsync(::std::move(iceP_pw), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getLog(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_first;
    int iceP_last;
    istr->readAll(iceP_first, iceP_last);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LogList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getLogAsync(iceP_first, iceP_last, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getLogLen(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getLogLenAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const UserMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getUsersAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getChannels(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ChannelMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getChannelsAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getCertificateList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    istr->readAll(iceP_session);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const CertificateList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getCertificateListAsync(iceP_session, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getTree(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<Tree>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->getTreeAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getBans(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BanList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getBansAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setBans(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    BanList iceP_bans;
    istr->readAll(iceP_bans);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setBansAsync(::std::move(iceP_bans), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_kickUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    ::std::string iceP_reason;
    istr->readAll(iceP_session, iceP_reason);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->kickUserAsync(iceP_session, ::std::move(iceP_reason), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    istr->readAll(iceP_session);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const User& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getStateAsync(iceP_session, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    User iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setStateAsync(::std::move(iceP_state), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_sendMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    ::std::string iceP_text;
    istr->readAll(iceP_session, iceP_text);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->sendMessageAsync(iceP_session, ::std::move(iceP_text), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_hasPermission(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    int iceP_channelid;
    int iceP_perm;
    istr->readAll(iceP_session, iceP_channelid, iceP_perm);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](bool ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->hasPermissionAsync(iceP_session, iceP_channelid, iceP_perm, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_effectivePermissions(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    int iceP_channelid;
    istr->readAll(iceP_session, iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->effectivePermissionsAsync(iceP_session, iceP_channelid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_addContextCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    ::std::string iceP_action;
    ::std::string iceP_text;
    ::std::shared_ptr<ServerContextCallbackPrx> iceP_cb;
    int iceP_ctx;
    istr->readAll(iceP_session, iceP_action, iceP_text, iceP_cb, iceP_ctx);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->addContextCallbackAsync(iceP_session, ::std::move(iceP_action), ::std::move(iceP_text), ::std::move(iceP_cb), iceP_ctx, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_removeContextCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerContextCallbackPrx> iceP_cb;
    istr->readAll(iceP_cb);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->removeContextCallbackAsync(::std::move(iceP_cb), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getChannelState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    istr->readAll(iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const Channel& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getChannelStateAsync(iceP_channelid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setChannelState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    Channel iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setChannelStateAsync(::std::move(iceP_state), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_removeChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    istr->readAll(iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->removeChannelAsync(iceP_channelid, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_addChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    int iceP_parent;
    istr->readAll(iceP_name, iceP_parent);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->addChannelAsync(::std::move(iceP_name), iceP_parent, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_sendMessageChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    bool iceP_tree;
    ::std::string iceP_text;
    istr->readAll(iceP_channelid, iceP_tree, iceP_text);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->sendMessageChannelAsync(iceP_channelid, iceP_tree, ::std::move(iceP_text), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getACL(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    istr->readAll(iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ACLList& iceP_acls, const GroupList& iceP_groups, bool iceP_inherit)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_acls, iceP_groups, iceP_inherit);
        inA->endWriteParams();
        inA->completed();
    };
    this->getACLAsync(iceP_channelid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setACL(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    ACLList iceP_acls;
    GroupList iceP_groups;
    bool iceP_inherit;
    istr->readAll(iceP_channelid, iceP_acls, iceP_groups, iceP_inherit);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setACLAsync(iceP_channelid, ::std::move(iceP_acls), ::std::move(iceP_groups), iceP_inherit, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_addUserToGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    int iceP_session;
    ::std::string iceP_group;
    istr->readAll(iceP_channelid, iceP_session, iceP_group);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->addUserToGroupAsync(iceP_channelid, iceP_session, ::std::move(iceP_group), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_removeUserFromGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    int iceP_session;
    ::std::string iceP_group;
    istr->readAll(iceP_channelid, iceP_session, iceP_group);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->removeUserFromGroupAsync(iceP_channelid, iceP_session, ::std::move(iceP_group), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_redirectWhisperGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    ::std::string iceP_source;
    ::std::string iceP_target;
    istr->readAll(iceP_session, iceP_source, iceP_target);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->redirectWhisperGroupAsync(iceP_session, ::std::move(iceP_source), ::std::move(iceP_target), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getUserNames(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    IdList iceP_ids;
    istr->readAll(iceP_ids);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const NameMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getUserNamesAsync(::std::move(iceP_ids), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getUserIds(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    NameList iceP_names;
    istr->readAll(iceP_names);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const IdMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getUserIdsAsync(::std::move(iceP_names), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_registerUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    UserInfoMap iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->registerUserAsync(::std::move(iceP_info), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_unregisterUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    istr->readAll(iceP_userid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->unregisterUserAsync(iceP_userid, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_updateRegistration(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    UserInfoMap iceP_info;
    istr->readAll(iceP_userid, iceP_info);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->updateRegistrationAsync(iceP_userid, ::std::move(iceP_info), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getRegistration(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    istr->readAll(iceP_userid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const UserInfoMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getRegistrationAsync(iceP_userid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getRegisteredUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_filter;
    istr->readAll(iceP_filter);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const NameMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getRegisteredUsersAsync(::std::move(iceP_filter), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_verifyPassword(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_pw;
    istr->readAll(iceP_name, iceP_pw);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->verifyPasswordAsync(::std::move(iceP_name), ::std::move(iceP_pw), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    istr->readAll(iceP_userid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const Texture& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getTextureAsync(iceP_userid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    Texture iceP_tex;
    istr->readAll(iceP_userid, iceP_tex);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setTextureAsync(iceP_userid, ::std::move(iceP_tex), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getUptime(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getUptimeAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_updateCertificate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_certificate;
    ::std::string iceP_privateKey;
    ::std::string iceP_passphrase;
    istr->readAll(iceP_certificate, iceP_privateKey, iceP_passphrase);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->updateCertificateAsync(::std::move(iceP_certificate), ::std::move(iceP_privateKey), ::std::move(iceP_passphrase), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_startListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    int iceP_channelid;
    istr->readAll(iceP_userid, iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->startListeningAsync(iceP_userid, iceP_channelid, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_stopListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    int iceP_channelid;
    istr->readAll(iceP_userid, iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->stopListeningAsync(iceP_userid, iceP_channelid, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_isListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    int iceP_channelid;
    istr->readAll(iceP_userid, iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](bool ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->isListeningAsync(iceP_userid, iceP_channelid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getListeningChannels(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    istr->readAll(iceP_userid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const IntList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getListeningChannelsAsync(iceP_userid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getListeningUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    istr->readAll(iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const IntList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getListeningUsersAsync(iceP_channelid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_sendWelcomeMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    IdList iceP_receiverUserIDs;
    istr->readAll(iceP_receiverUserIDs);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->sendWelcomeMessageAsync(::std::move(iceP_receiverUserIDs), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_Server_ops, iceC_Murmur_Server_ops + 60, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_Server_ops)
    {
        case 0:
        {
            return _iceD_addCallback(in, current);
        }
        case 1:
        {
            return _iceD_addChannel(in, current);
        }
        case 2:
        {
            return _iceD_addContextCallback(in, current);
        }
        case 3:
        {
            return _iceD_addUserToGroup(in, current);
        }
        case 4:
        {
            return _iceD_delete(in, current);
        }
        case 5:
        {
            return _iceD_effectivePermissions(in, current);
        }
        case 6:
        {
            return _iceD_getACL(in, current);
        }
        case 7:
        {
            return _iceD_getAllConf(in, current);
        }
        case 8:
        {
            return _iceD_getBans(in, current);
        }
        case 9:
        {
            return _iceD_getCertificateList(in, current);
        }
        case 10:
        {
            return _iceD_getChannelState(in, current);
        }
        case 11:
        {
            return _iceD_getChannels(in, current);
        }
        case 12:
        {
            return _iceD_getConf(in, current);
        }
        case 13:
        {
            return _iceD_getListeningChannels(in, current);
        }
        case 14:
        {
            return _iceD_getListeningUsers(in, current);
        }
        case 15:
        {
            return _iceD_getLog(in, current);
        }
        case 16:
        {
            return _iceD_getLogLen(in, current);
        }
        case 17:
        {
            return _iceD_getRegisteredUsers(in, current);
        }
        case 18:
        {
            return _iceD_getRegistration(in, current);
        }
        case 19:
        {
            return _iceD_getState(in, current);
        }
        case 20:
        {
            return _iceD_getTexture(in, current);
        }
        case 21:
        {
            return _iceD_getTree(in, current);
        }
        case 22:
        {
            return _iceD_getUptime(in, current);
        }
        case 23:
        {
            return _iceD_getUserIds(in, current);
        }
        case 24:
        {
            return _iceD_getUserNames(in, current);
        }
        case 25:
        {
            return _iceD_getUsers(in, current);
        }
        case 26:
        {
            return _iceD_hasPermission(in, current);
        }
        case 27:
        {
            return _iceD_ice_id(in, current);
        }
        case 28:
        {
            return _iceD_ice_ids(in, current);
        }
        case 29:
        {
            return _iceD_ice_isA(in, current);
        }
        case 30:
        {
            return _iceD_ice_ping(in, current);
        }
        case 31:
        {
            return _iceD_id(in, current);
        }
        case 32:
        {
            return _iceD_isListening(in, current);
        }
        case 33:
        {
            return _iceD_isRunning(in, current);
        }
        case 34:
        {
            return _iceD_kickUser(in, current);
        }
        case 35:
        {
            return _iceD_redirectWhisperGroup(in, current);
        }
        case 36:
        {
            return _iceD_registerUser(in, current);
        }
        case 37:
        {
            return _iceD_removeCallback(in, current);
        }
        case 38:
        {
            return _iceD_removeChannel(in, current);
        }
        case 39:
        {
            return _iceD_removeContextCallback(in, current);
        }
        case 40:
        {
            return _iceD_removeUserFromGroup(in, current);
        }
        case 41:
        {
            return _iceD_sendMessage(in, current);
        }
        case 42:
        {
            return _iceD_sendMessageChannel(in, current);
        }
        case 43:
        {
            return _iceD_sendWelcomeMessage(in, current);
        }
        case 44:
        {
            return _iceD_setACL(in, current);
        }
        case 45:
        {
            return _iceD_setAuthenticator(in, current);
        }
        case 46:
        {
            return _iceD_setBans(in, current);
        }
        case 47:
        {
            return _iceD_setChannelState(in, current);
        }
        case 48:
        {
            return _iceD_setConf(in, current);
        }
        case 49:
        {
            return _iceD_setState(in, current);
        }
        case 50:
        {
            return _iceD_setSuperuserPassword(in, current);
        }
        case 51:
        {
            return _iceD_setTexture(in, current);
        }
        case 52:
        {
            return _iceD_start(in, current);
        }
        case 53:
        {
            return _iceD_startListening(in, current);
        }
        case 54:
        {
            return _iceD_stop(in, current);
        }
        case 55:
        {
            return _iceD_stopListening(in, current);
        }
        case 56:
        {
            return _iceD_unregisterUser(in, current);
        }
        case 57:
        {
            return _iceD_updateCertificate(in, current);
        }
        case 58:
        {
            return _iceD_updateRegistration(in, current);
        }
        case 59:
        {
            return _iceD_verifyPassword(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Murmur::MetaCallback::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_MetaCallback_ids, iceC_Murmur_MetaCallback_ids + 2, s);
}

::std::vector<::std::string>
Murmur::MetaCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Murmur_MetaCallback_ids[0], &iceC_Murmur_MetaCallback_ids[2]);
}

::std::string
Murmur::MetaCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::MetaCallback::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::MetaCallback";
    return typeId;
}

/// \cond INTERNAL
bool
Murmur::MetaCallback::_iceD_started(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerPrx> iceP_srv;
    istr->readAll(iceP_srv);
    inS.endReadParams();
    this->started(::std::move(iceP_srv), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::MetaCallback::_iceD_stopped(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerPrx> iceP_srv;
    istr->readAll(iceP_srv);
    inS.endReadParams();
    this->stopped(::std::move(iceP_srv), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::MetaCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_MetaCallback_ops, iceC_Murmur_MetaCallback_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_MetaCallback_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_started(in, current);
        }
        case 5:
        {
            return _iceD_stopped(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Murmur::Meta::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_Meta_ids, iceC_Murmur_Meta_ids + 2, s);
}

::std::vector<::std::string>
Murmur::Meta::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Murmur_Meta_ids[0], &iceC_Murmur_Meta_ids[2]);
}

::std::string
Murmur::Meta::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::Meta::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::Meta";
    return typeId;
}

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<ServerPrx>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getServerAsync(iceP_id, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_newServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<ServerPrx>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->newServerAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getBootedServers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ServerList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getBootedServersAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getAllServers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ServerList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getAllServersAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getDefaultConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ConfigMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getDefaultConfAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int iceP_major, int iceP_minor, int iceP_patch, const ::std::string& iceP_text)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_major, iceP_minor, iceP_patch, iceP_text);
        inA->endWriteParams();
        inA->completed();
    };
    this->getVersionAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_addCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<MetaCallbackPrx> iceP_cb;
    istr->readAll(iceP_cb);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->addCallbackAsync(::std::move(iceP_cb), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_removeCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<MetaCallbackPrx> iceP_cb;
    istr->readAll(iceP_cb);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->removeCallbackAsync(::std::move(iceP_cb), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getUptime(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getUptimeAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getSlice(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::string& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getSliceAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getSliceChecksums(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::Ice::SliceChecksumDict& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getSliceChecksumsAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_Meta_ops, iceC_Murmur_Meta_ops + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_Meta_ops)
    {
        case 0:
        {
            return _iceD_addCallback(in, current);
        }
        case 1:
        {
            return _iceD_getAllServers(in, current);
        }
        case 2:
        {
            return _iceD_getBootedServers(in, current);
        }
        case 3:
        {
            return _iceD_getDefaultConf(in, current);
        }
        case 4:
        {
            return _iceD_getServer(in, current);
        }
        case 5:
        {
            return _iceD_getSlice(in, current);
        }
        case 6:
        {
            return _iceD_getSliceChecksums(in, current);
        }
        case 7:
        {
            return _iceD_getUptime(in, current);
        }
        case 8:
        {
            return _iceD_getVersion(in, current);
        }
        case 9:
        {
            return _iceD_ice_id(in, current);
        }
        case 10:
        {
            return _iceD_ice_ids(in, current);
        }
        case 11:
        {
            return _iceD_ice_isA(in, current);
        }
        case 12:
        {
            return _iceD_ice_ping(in, current);
        }
        case 13:
        {
            return _iceD_newServer(in, current);
        }
        case 14:
        {
            return _iceD_removeCallback(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Murmur::Tree::~Tree()
{
}

const ::std::string&
Murmur::Tree::ice_staticId()
{
    static const ::std::string typeId = "::Murmur::Tree";
    return typeId;
}

/// \cond INTERNAL
void
Murmur::ServerCallbackPrx::_iceI_userConnected(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const User& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_ServerCallback_userConnected_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerCallbackPrx::_iceI_userDisconnected(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const User& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_ServerCallback_userDisconnected_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerCallbackPrx::_iceI_userStateChanged(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const User& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_ServerCallback_userStateChanged_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerCallbackPrx::_iceI_userTextMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const User& iceP_state, const TextMessage& iceP_message, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_ServerCallback_userTextMessage_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state, iceP_message);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerCallbackPrx::_iceI_channelCreated(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const Channel& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_ServerCallback_channelCreated_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerCallbackPrx::_iceI_channelRemoved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const Channel& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_ServerCallback_channelRemoved_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerCallbackPrx::_iceI_channelStateChanged(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const Channel& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_ServerCallback_channelStateChanged_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Murmur::ServerCallbackPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerCallbackPrx>();
}
/// \endcond

const ::std::string&
Murmur::ServerCallbackPrx::ice_staticId()
{
    return ServerCallback::ice_staticId();
}

/// \cond INTERNAL
void
Murmur::ServerContextCallbackPrx::_iceI_contextAction(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_action, const User& iceP_usr, int iceP_session, int iceP_channelid, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_ServerContextCallback_contextAction_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_action, iceP_usr, iceP_session, iceP_channelid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Murmur::ServerContextCallbackPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerContextCallbackPrx>();
}
/// \endcond

const ::std::string&
Murmur::ServerContextCallbackPrx::ice_staticId()
{
    return ServerContextCallback::ice_staticId();
}

/// \cond INTERNAL
void
Murmur::ServerAuthenticatorPrx::_iceI_authenticate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAuthenticator::AuthenticateResult>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_pw, const CertificateList& iceP_certificates, const ::std::string& iceP_certhash, bool iceP_certstrong, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_ServerAuthenticator_authenticate_name);
    outAsync->invoke(iceC_Murmur_ServerAuthenticator_authenticate_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ServerAuthenticator::AuthenticateResult v;
            istr->readAll(v.newname, v.groups, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerAuthenticatorPrx::_iceI_getInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAuthenticator::GetInfoResult>>& outAsync, int iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_ServerAuthenticator_getInfo_name);
    outAsync->invoke(iceC_Murmur_ServerAuthenticator_getInfo_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ServerAuthenticator::GetInfoResult v;
            istr->readAll(v.info, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerAuthenticatorPrx::_iceI_nameToId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_ServerAuthenticator_nameToId_name);
    outAsync->invoke(iceC_Murmur_ServerAuthenticator_nameToId_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerAuthenticatorPrx::_iceI_idToName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_ServerAuthenticator_idToName_name);
    outAsync->invoke(iceC_Murmur_ServerAuthenticator_idToName_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerAuthenticatorPrx::_iceI_idToTexture(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::Texture>>& outAsync, int iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_ServerAuthenticator_idToTexture_name);
    outAsync->invoke(iceC_Murmur_ServerAuthenticator_idToTexture_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Murmur::ServerAuthenticatorPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerAuthenticatorPrx>();
}
/// \endcond

const ::std::string&
Murmur::ServerAuthenticatorPrx::ice_staticId()
{
    return ServerAuthenticator::ice_staticId();
}

/// \cond INTERNAL
void
Murmur::ServerUpdatingAuthenticatorPrx::_iceI_registerUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const UserInfoMap& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_ServerUpdatingAuthenticator_registerUser_name);
    outAsync->invoke(iceC_Murmur_ServerUpdatingAuthenticator_registerUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerUpdatingAuthenticatorPrx::_iceI_unregisterUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_ServerUpdatingAuthenticator_unregisterUser_name);
    outAsync->invoke(iceC_Murmur_ServerUpdatingAuthenticator_unregisterUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerUpdatingAuthenticatorPrx::_iceI_getRegisteredUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::NameMap>>& outAsync, const ::std::string& iceP_filter, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_ServerUpdatingAuthenticator_getRegisteredUsers_name);
    outAsync->invoke(iceC_Murmur_ServerUpdatingAuthenticator_getRegisteredUsers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_filter);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerUpdatingAuthenticatorPrx::_iceI_setInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_id, const UserInfoMap& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_ServerUpdatingAuthenticator_setInfo_name);
    outAsync->invoke(iceC_Murmur_ServerUpdatingAuthenticator_setInfo_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerUpdatingAuthenticatorPrx::_iceI_setTexture(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_id, const Texture& iceP_tex, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_ServerUpdatingAuthenticator_setTexture_name);
    outAsync->invoke(iceC_Murmur_ServerUpdatingAuthenticator_setTexture_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_tex);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Murmur::ServerUpdatingAuthenticatorPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerUpdatingAuthenticatorPrx>();
}
/// \endcond

const ::std::string&
Murmur::ServerUpdatingAuthenticatorPrx::ice_staticId()
{
    return ServerUpdatingAuthenticator::ice_staticId();
}

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_isRunning(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_isRunning_name);
    outAsync->invoke(iceC_Murmur_Server_isRunning_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_start(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_start_name);
    outAsync->invoke(iceC_Murmur_Server_start_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ServerFailureException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_stop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_stop_name);
    outAsync->invoke(iceC_Murmur_Server_stop_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_delete(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_delete_name);
    outAsync->invoke(iceC_Murmur_Server_delete_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_id(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_id_name);
    outAsync->invoke(iceC_Murmur_Server_id_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_addCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerCallbackPrx>& iceP_cb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_addCallback_name);
    outAsync->invoke(iceC_Murmur_Server_addCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cb);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_removeCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerCallbackPrx>& iceP_cb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_removeCallback_name);
    outAsync->invoke(iceC_Murmur_Server_removeCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cb);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_setAuthenticator(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerAuthenticatorPrx>& iceP_auth, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_setAuthenticator_name);
    outAsync->invoke(iceC_Murmur_Server_setAuthenticator_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_auth);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getConf(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::std::string& iceP_key, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getConf_name);
    outAsync->invoke(iceC_Murmur_Server_getConf_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_key);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const WriteOnlyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getAllConf(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::ConfigMap>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getAllConf_name);
    outAsync->invoke(iceC_Murmur_Server_getAllConf_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_setConf(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_key, const ::std::string& iceP_value, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_setConf_name);
    outAsync->invoke(iceC_Murmur_Server_setConf_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_key, iceP_value);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_setSuperuserPassword(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_pw, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_setSuperuserPassword_name);
    outAsync->invoke(iceC_Murmur_Server_setSuperuserPassword_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pw);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getLog(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::LogList>>& outAsync, int iceP_first, int iceP_last, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getLog_name);
    outAsync->invoke(iceC_Murmur_Server_getLog_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_first, iceP_last);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getLogLen(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getLogLen_name);
    outAsync->invoke(iceC_Murmur_Server_getLogLen_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::UserMap>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getUsers_name);
    outAsync->invoke(iceC_Murmur_Server_getUsers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getChannels(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::ChannelMap>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getChannels_name);
    outAsync->invoke(iceC_Murmur_Server_getChannels_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getCertificateList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::CertificateList>>& outAsync, int iceP_session, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getCertificateList_name);
    outAsync->invoke(iceC_Murmur_Server_getCertificateList_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getTree(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Murmur::Tree>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getTree_name);
    outAsync->invoke(iceC_Murmur_Server_getTree_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Tree> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getBans(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::BanList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getBans_name);
    outAsync->invoke(iceC_Murmur_Server_getBans_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_setBans(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const BanList& iceP_bans, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_setBans_name);
    outAsync->invoke(iceC_Murmur_Server_setBans_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_bans);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_kickUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_session, const ::std::string& iceP_reason, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_kickUser_name);
    outAsync->invoke(iceC_Murmur_Server_kickUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_reason);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::User>>& outAsync, int iceP_session, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getState_name);
    outAsync->invoke(iceC_Murmur_Server_getState_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_setState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const User& iceP_state, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_setState_name);
    outAsync->invoke(iceC_Murmur_Server_setState_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_sendMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_session, const ::std::string& iceP_text, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_sendMessage_name);
    outAsync->invoke(iceC_Murmur_Server_sendMessage_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_text);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_hasPermission(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, int iceP_session, int iceP_channelid, int iceP_perm, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_hasPermission_name);
    outAsync->invoke(iceC_Murmur_Server_hasPermission_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_channelid, iceP_perm);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_effectivePermissions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_session, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_effectivePermissions_name);
    outAsync->invoke(iceC_Murmur_Server_effectivePermissions_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_channelid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_addContextCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_session, const ::std::string& iceP_action, const ::std::string& iceP_text, const ::std::shared_ptr<ServerContextCallbackPrx>& iceP_cb, int iceP_ctx, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_addContextCallback_name);
    outAsync->invoke(iceC_Murmur_Server_addContextCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_action, iceP_text, iceP_cb, iceP_ctx);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_removeContextCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerContextCallbackPrx>& iceP_cb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_removeContextCallback_name);
    outAsync->invoke(iceC_Murmur_Server_removeContextCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cb);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getChannelState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::Channel>>& outAsync, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getChannelState_name);
    outAsync->invoke(iceC_Murmur_Server_getChannelState_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_setChannelState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const Channel& iceP_state, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_setChannelState_name);
    outAsync->invoke(iceC_Murmur_Server_setChannelState_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const NestingLimitException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_removeChannel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_removeChannel_name);
    outAsync->invoke(iceC_Murmur_Server_removeChannel_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_addChannel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::std::string& iceP_name, int iceP_parent, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_addChannel_name);
    outAsync->invoke(iceC_Murmur_Server_addChannel_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_parent);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const NestingLimitException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_sendMessageChannel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, bool iceP_tree, const ::std::string& iceP_text, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_sendMessageChannel_name);
    outAsync->invoke(iceC_Murmur_Server_sendMessageChannel_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid, iceP_tree, iceP_text);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getACL(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Server::GetACLResult>>& outAsync, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getACL_name);
    outAsync->invoke(iceC_Murmur_Server_getACL_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            Server::GetACLResult v;
            istr->readAll(v.acls, v.groups, v.inherit);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_setACL(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, const ACLList& iceP_acls, const GroupList& iceP_groups, bool iceP_inherit, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_setACL_name);
    outAsync->invoke(iceC_Murmur_Server_setACL_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid, iceP_acls, iceP_groups, iceP_inherit);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_addUserToGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, int iceP_session, const ::std::string& iceP_group, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_addUserToGroup_name);
    outAsync->invoke(iceC_Murmur_Server_addUserToGroup_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid, iceP_session, iceP_group);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_removeUserFromGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, int iceP_session, const ::std::string& iceP_group, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_removeUserFromGroup_name);
    outAsync->invoke(iceC_Murmur_Server_removeUserFromGroup_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid, iceP_session, iceP_group);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_redirectWhisperGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_session, const ::std::string& iceP_source, const ::std::string& iceP_target, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_redirectWhisperGroup_name);
    outAsync->invoke(iceC_Murmur_Server_redirectWhisperGroup_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_source, iceP_target);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getUserNames(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::NameMap>>& outAsync, const IdList& iceP_ids, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getUserNames_name);
    outAsync->invoke(iceC_Murmur_Server_getUserNames_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_ids);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getUserIds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::IdMap>>& outAsync, const NameList& iceP_names, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getUserIds_name);
    outAsync->invoke(iceC_Murmur_Server_getUserIds_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_names);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_registerUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const UserInfoMap& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_registerUser_name);
    outAsync->invoke(iceC_Murmur_Server_registerUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_unregisterUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_userid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_unregisterUser_name);
    outAsync->invoke(iceC_Murmur_Server_unregisterUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_updateRegistration(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_userid, const UserInfoMap& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_updateRegistration_name);
    outAsync->invoke(iceC_Murmur_Server_updateRegistration_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid, iceP_info);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getRegistration(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::UserInfoMap>>& outAsync, int iceP_userid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getRegistration_name);
    outAsync->invoke(iceC_Murmur_Server_getRegistration_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getRegisteredUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::NameMap>>& outAsync, const ::std::string& iceP_filter, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getRegisteredUsers_name);
    outAsync->invoke(iceC_Murmur_Server_getRegisteredUsers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_filter);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_verifyPassword(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_pw, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_verifyPassword_name);
    outAsync->invoke(iceC_Murmur_Server_verifyPassword_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_pw);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getTexture(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::Texture>>& outAsync, int iceP_userid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getTexture_name);
    outAsync->invoke(iceC_Murmur_Server_getTexture_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_setTexture(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_userid, const Texture& iceP_tex, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_setTexture_name);
    outAsync->invoke(iceC_Murmur_Server_setTexture_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid, iceP_tex);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidTextureException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getUptime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getUptime_name);
    outAsync->invoke(iceC_Murmur_Server_getUptime_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_updateCertificate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_certificate, const ::std::string& iceP_privateKey, const ::std::string& iceP_passphrase, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_updateCertificate_name);
    outAsync->invoke(iceC_Murmur_Server_updateCertificate_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_certificate, iceP_privateKey, iceP_passphrase);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidInputDataException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_startListening(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_userid, int iceP_channelid, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_Server_startListening_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid, iceP_channelid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_stopListening(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_userid, int iceP_channelid, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_Server_stopListening_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid, iceP_channelid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_isListening(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, int iceP_userid, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_isListening_name);
    outAsync->invoke(iceC_Murmur_Server_isListening_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid, iceP_channelid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getListeningChannels(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::IntList>>& outAsync, int iceP_userid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getListeningChannels_name);
    outAsync->invoke(iceC_Murmur_Server_getListeningChannels_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_getListeningUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::IntList>>& outAsync, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Server_getListeningUsers_name);
    outAsync->invoke(iceC_Murmur_Server_getListeningUsers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::ServerPrx::_iceI_sendWelcomeMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const IdList& iceP_receiverUserIDs, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_Server_sendWelcomeMessage_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_receiverUserIDs);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Murmur::ServerPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerPrx>();
}
/// \endcond

const ::std::string&
Murmur::ServerPrx::ice_staticId()
{
    return Server::ice_staticId();
}

/// \cond INTERNAL
void
Murmur::MetaCallbackPrx::_iceI_started(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerPrx>& iceP_srv, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_MetaCallback_started_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_srv);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaCallbackPrx::_iceI_stopped(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerPrx>& iceP_srv, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Murmur_MetaCallback_stopped_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_srv);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Murmur::MetaCallbackPrx::_newInstance() const
{
    return ::IceInternal::createProxy<MetaCallbackPrx>();
}
/// \endcond

const ::std::string&
Murmur::MetaCallbackPrx::ice_staticId()
{
    return MetaCallback::ice_staticId();
}

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_getServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Murmur::ServerPrx>>>& outAsync, int iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getServer_name);
    outAsync->invoke(iceC_Murmur_Meta_getServer_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_newServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Murmur::ServerPrx>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_newServer_name);
    outAsync->invoke(iceC_Murmur_Meta_newServer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_getBootedServers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::ServerList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getBootedServers_name);
    outAsync->invoke(iceC_Murmur_Meta_getBootedServers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_getAllServers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::ServerList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getAllServers_name);
    outAsync->invoke(iceC_Murmur_Meta_getAllServers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_getDefaultConf(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Murmur::ConfigMap>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getDefaultConf_name);
    outAsync->invoke(iceC_Murmur_Meta_getDefaultConf_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_getVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Meta::GetVersionResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getVersion_name);
    outAsync->invoke(iceC_Murmur_Meta_getVersion_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Meta::GetVersionResult v;
            istr->readAll(v.major, v.minor, v.patch, v.text);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_addCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<MetaCallbackPrx>& iceP_cb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_addCallback_name);
    outAsync->invoke(iceC_Murmur_Meta_addCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cb);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_removeCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<MetaCallbackPrx>& iceP_cb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_removeCallback_name);
    outAsync->invoke(iceC_Murmur_Meta_removeCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cb);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_getUptime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getUptime_name);
    outAsync->invoke(iceC_Murmur_Meta_getUptime_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_getSlice(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getSlice_name);
    outAsync->invoke(iceC_Murmur_Meta_getSlice_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Murmur::MetaPrx::_iceI_getSliceChecksums(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::SliceChecksumDict>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getSliceChecksums_name);
    outAsync->invoke(iceC_Murmur_Meta_getSliceChecksums_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Murmur::MetaPrx::_newInstance() const
{
    return ::IceInternal::createProxy<MetaPrx>();
}
/// \endcond

const ::std::string&
Murmur::MetaPrx::ice_staticId()
{
    return Meta::ice_staticId();
}

namespace Ice
{
}

namespace
{

const char* iceSliceChecksums[] =
{
    "::Murmur::ACL", "157797fb27cda83faec7e5374284e275",
    "::Murmur::ACLList", "c0d51a6dadd205ea4ceed3ab8605e",
    "::Murmur::Ban", "77c83f17e3b1603f5d35b47fa33870",
    "::Murmur::BanList", "0c7df186822caffee1c2391a82de0a8",
    "::Murmur::CertificateDer", "bda5350e8ec40eef1cae7c2b3c616cf",
    "::Murmur::CertificateList", "bb8d3e415f174d82a74a3abebeadc0",
    "::Murmur::Channel", "3d7546228b98475e03e4bd2eef7042",
    "::Murmur::ChannelInfo", "1e1c915adb3475dd6aa6943aff139d7c",
    "::Murmur::ChannelList", "b6a00a1063ca328741442333853ac",
    "::Murmur::ChannelMap", "c680d84f229348aeac44fceda7a02cc8",
    "::Murmur::ConfigMap", "a959102c70f61ff099b044a145ba2a",
    "::Murmur::ContextChannel", "d031ddb65dbaea316b6718ffa867852",
    "::Murmur::ContextServer", "36637f606caa3dfe7a88816f3d1d4b4",
    "::Murmur::ContextUser", "928e6ca841dc5467d671cc7e94a47b1",
    "::Murmur::Group", "351a3b2b4d272047beca8770793874b",
    "::Murmur::GroupList", "cbca3d925b7b06eb1d0ca15379977e8",
    "::Murmur::GroupNameList", "3129349326861d482a77548514a44ea9",
    "::Murmur::IdList", "ee9f8c35179c12487ff62e359b7f267b",
    "::Murmur::IdMap", "36f07840567acf5a1a182b80cc4ec4c8",
    "::Murmur::IntList", "6f1c32278d7993b8e7fcab62838cfa6",
    "::Murmur::InvalidCallbackException", "8f793feff89155d9b9b47cd11c283f",
    "::Murmur::InvalidChannelException", "551df6f38d8243dfc01b8ae610f0a41b",
    "::Murmur::InvalidInputDataException", "f28c685e6e2ccaa11687822d24d80ba",
    "::Murmur::InvalidSecretException", "2fb9069906614c74d6f54ffb7299723",
    "::Murmur::InvalidServerException", "8c23808992774379fd0deede158a24d",
    "::Murmur::InvalidSessionException", "411551c2f6abb9aa68b0dce4da1f2261",
    "::Murmur::InvalidTextureException", "c2f0fb931df3ceac9f3b231d90d1f66a",
    "::Murmur::InvalidUserException", "deaaf2325132ceebde9ba71eae8aae0",
    "::Murmur::LogEntry", "baf7375450f0cf5a4221ac1080297efb",
    "::Murmur::LogList", "816cdfe716397174d44069acd3309836",
    "::Murmur::Meta", "11f0c26da8d8ffb8135a7028ddfe43e",
    "::Murmur::MetaCallback", "8769511071e0b08b8dfc4b1ca1c352a",
    "::Murmur::MurmurException", "f14e757fac3ec91e3eb581beaf8d1af",
    "::Murmur::NameList", "492b93e2b12d2bd7f61f719a67b8623b",
    "::Murmur::NameMap", "8eb7985198a0add716b9462cbdd8c",
    "::Murmur::NestingLimitException", "f7a9a488daca3d97d689debc832c76",
    "::Murmur::NetAddress", "fe2a565d478baf1e5e2168ca4492d9d",
    "::Murmur::PermissionBan", "ac198d670d743c882937073eae3247",
    "::Murmur::PermissionEnter", "54fa28c949285c187f4df657b087b8",
    "::Murmur::PermissionKick", "15a8e0bcd0862dba4b5b72550f09aad",
    "::Murmur::PermissionLinkChannel", "992d2978f5eb8c5c5c8ec68aee4f890",
    "::Murmur::PermissionMakeChannel", "7cb412acce465d84c9a11bc5cd43e66",
    "::Murmur::PermissionMakeTempChannel", "beeec37912c744f855149ab30608344",
    "::Murmur::PermissionMove", "19f25e8a3ccabbbdf7316a675d6cc87",
    "::Murmur::PermissionMuteDeafen", "53c56b4bd8cf231a4090ef24ed893939",
    "::Murmur::PermissionRegister", "d0c4e13de6abc868b79cf01bb7d5c1ad",
    "::Murmur::PermissionRegisterSelf", "3a9718827e1cdc13b1fde4a724df8",
    "::Murmur::PermissionSpeak", "cfd814f27bac13db9c9a342a0512a4b",
    "::Murmur::PermissionTextMessage", "b5d36eeecdffc56a3a72854a1469145b",
    "::Murmur::PermissionTraverse", "37f12b9bb96c0d07a7c45e1bfef0fe",
    "::Murmur::PermissionWhisper", "dddf47c35e992f8cd868c4321f9bcb",
    "::Murmur::PermissionWrite", "a939b87d29f9fff8b2f957b3e4b121c0",
    "::Murmur::ResetUserContent", "144ba8653415acdee3d3f946a18058",
    "::Murmur::Server", "6ae1cdc268e435bab7cbab20a5697acb",
    "::Murmur::ServerAuthenticator", "53d631793acaba02db8a24971d9032",
    "::Murmur::ServerBootedException", "ddeb7c96e12425ac5fa5a6a94f956",
    "::Murmur::ServerCallback", "8963c15b917c6dac6ab1a7abdbd",
    "::Murmur::ServerContextCallback", "aa3c7926b1cea864d4a280e116ce42",
    "::Murmur::ServerFailureException", "1fe7854e87d2f446c8ff19f38043e821",
    "::Murmur::ServerList", "c4b0f170133f5681b162f8eff53fe",
    "::Murmur::ServerUpdatingAuthenticator", "ad94f3cb11cd39bf69ad81f879af45f",
    "::Murmur::TextMessage", "31d8456b13daf9ab43832a7b381f73b7",
    "::Murmur::Texture", "141dd3bb5aa45668e290153de4e8a23c",
    "::Murmur::Tree", "d22bc269c9dab07c1ff38be14e4bf89",
    "::Murmur::TreeList", "d7942bdad7624ea9e13a297b75fa7da",
    "::Murmur::User", "b0d23475ce2fc5fd59558ea55796946",
    "::Murmur::UserInfo", "3c1a3c8ac61325a80f23f21e5466294",
    "::Murmur::UserInfoMap", "422b99b6357d73912dfea65a794c41a6",
    "::Murmur::UserList", "629ef93051c372dd4ab85895fd9d311",
    "::Murmur::UserMap", "787e8028481a284f43687305c91473",
    "::Murmur::WriteOnlyException", "8aca8bfe9c995581fe3dc942c5a342b",
    0
};
const IceInternal::SliceChecksumInit iceSliceChecksumInit(iceSliceChecksums);

}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Murmur_ServerCallback_userConnected_name = "userConnected";

const ::std::string iceC_Murmur_ServerCallback_userDisconnected_name = "userDisconnected";

const ::std::string iceC_Murmur_ServerCallback_userStateChanged_name = "userStateChanged";

const ::std::string iceC_Murmur_ServerCallback_userTextMessage_name = "userTextMessage";

const ::std::string iceC_Murmur_ServerCallback_channelCreated_name = "channelCreated";

const ::std::string iceC_Murmur_ServerCallback_channelRemoved_name = "channelRemoved";

const ::std::string iceC_Murmur_ServerCallback_channelStateChanged_name = "channelStateChanged";

const ::std::string iceC_Murmur_ServerContextCallback_contextAction_name = "contextAction";

const ::std::string iceC_Murmur_ServerAuthenticator_authenticate_name = "authenticate";

const ::std::string iceC_Murmur_ServerAuthenticator_getInfo_name = "getInfo";

const ::std::string iceC_Murmur_ServerAuthenticator_nameToId_name = "nameToId";

const ::std::string iceC_Murmur_ServerAuthenticator_idToName_name = "idToName";

const ::std::string iceC_Murmur_ServerAuthenticator_idToTexture_name = "idToTexture";

const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_registerUser_name = "registerUser";

const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_unregisterUser_name = "unregisterUser";

const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_getRegisteredUsers_name = "getRegisteredUsers";

const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_setInfo_name = "setInfo";

const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_setTexture_name = "setTexture";

const ::std::string iceC_Murmur_Server_isRunning_name = "isRunning";

const ::std::string iceC_Murmur_Server_start_name = "start";

const ::std::string iceC_Murmur_Server_stop_name = "stop";

const ::std::string iceC_Murmur_Server_delete_name = "delete";

const ::std::string iceC_Murmur_Server_id_name = "id";

const ::std::string iceC_Murmur_Server_addCallback_name = "addCallback";

const ::std::string iceC_Murmur_Server_removeCallback_name = "removeCallback";

const ::std::string iceC_Murmur_Server_setAuthenticator_name = "setAuthenticator";

const ::std::string iceC_Murmur_Server_getConf_name = "getConf";

const ::std::string iceC_Murmur_Server_getAllConf_name = "getAllConf";

const ::std::string iceC_Murmur_Server_setConf_name = "setConf";

const ::std::string iceC_Murmur_Server_setSuperuserPassword_name = "setSuperuserPassword";

const ::std::string iceC_Murmur_Server_getLog_name = "getLog";

const ::std::string iceC_Murmur_Server_getLogLen_name = "getLogLen";

const ::std::string iceC_Murmur_Server_getUsers_name = "getUsers";

const ::std::string iceC_Murmur_Server_getChannels_name = "getChannels";

const ::std::string iceC_Murmur_Server_getCertificateList_name = "getCertificateList";

const ::std::string iceC_Murmur_Server_getTree_name = "getTree";

const ::std::string iceC_Murmur_Server_getBans_name = "getBans";

const ::std::string iceC_Murmur_Server_setBans_name = "setBans";

const ::std::string iceC_Murmur_Server_kickUser_name = "kickUser";

const ::std::string iceC_Murmur_Server_getState_name = "getState";

const ::std::string iceC_Murmur_Server_setState_name = "setState";

const ::std::string iceC_Murmur_Server_sendMessage_name = "sendMessage";

const ::std::string iceC_Murmur_Server_hasPermission_name = "hasPermission";

const ::std::string iceC_Murmur_Server_effectivePermissions_name = "effectivePermissions";

const ::std::string iceC_Murmur_Server_addContextCallback_name = "addContextCallback";

const ::std::string iceC_Murmur_Server_removeContextCallback_name = "removeContextCallback";

const ::std::string iceC_Murmur_Server_getChannelState_name = "getChannelState";

const ::std::string iceC_Murmur_Server_setChannelState_name = "setChannelState";

const ::std::string iceC_Murmur_Server_removeChannel_name = "removeChannel";

const ::std::string iceC_Murmur_Server_addChannel_name = "addChannel";

const ::std::string iceC_Murmur_Server_sendMessageChannel_name = "sendMessageChannel";

const ::std::string iceC_Murmur_Server_getACL_name = "getACL";

const ::std::string iceC_Murmur_Server_setACL_name = "setACL";

const ::std::string iceC_Murmur_Server_addUserToGroup_name = "addUserToGroup";

const ::std::string iceC_Murmur_Server_removeUserFromGroup_name = "removeUserFromGroup";

const ::std::string iceC_Murmur_Server_redirectWhisperGroup_name = "redirectWhisperGroup";

const ::std::string iceC_Murmur_Server_getUserNames_name = "getUserNames";

const ::std::string iceC_Murmur_Server_getUserIds_name = "getUserIds";

const ::std::string iceC_Murmur_Server_registerUser_name = "registerUser";

const ::std::string iceC_Murmur_Server_unregisterUser_name = "unregisterUser";

const ::std::string iceC_Murmur_Server_updateRegistration_name = "updateRegistration";

const ::std::string iceC_Murmur_Server_getRegistration_name = "getRegistration";

const ::std::string iceC_Murmur_Server_getRegisteredUsers_name = "getRegisteredUsers";

const ::std::string iceC_Murmur_Server_verifyPassword_name = "verifyPassword";

const ::std::string iceC_Murmur_Server_getTexture_name = "getTexture";

const ::std::string iceC_Murmur_Server_setTexture_name = "setTexture";

const ::std::string iceC_Murmur_Server_getUptime_name = "getUptime";

const ::std::string iceC_Murmur_Server_updateCertificate_name = "updateCertificate";

const ::std::string iceC_Murmur_Server_startListening_name = "startListening";

const ::std::string iceC_Murmur_Server_stopListening_name = "stopListening";

const ::std::string iceC_Murmur_Server_isListening_name = "isListening";

const ::std::string iceC_Murmur_Server_getListeningChannels_name = "getListeningChannels";

const ::std::string iceC_Murmur_Server_getListeningUsers_name = "getListeningUsers";

const ::std::string iceC_Murmur_Server_sendWelcomeMessage_name = "sendWelcomeMessage";

const ::std::string iceC_Murmur_MetaCallback_started_name = "started";

const ::std::string iceC_Murmur_MetaCallback_stopped_name = "stopped";

const ::std::string iceC_Murmur_Meta_getServer_name = "getServer";

const ::std::string iceC_Murmur_Meta_newServer_name = "newServer";

const ::std::string iceC_Murmur_Meta_getBootedServers_name = "getBootedServers";

const ::std::string iceC_Murmur_Meta_getAllServers_name = "getAllServers";

const ::std::string iceC_Murmur_Meta_getDefaultConf_name = "getDefaultConf";

const ::std::string iceC_Murmur_Meta_getVersion_name = "getVersion";

const ::std::string iceC_Murmur_Meta_addCallback_name = "addCallback";

const ::std::string iceC_Murmur_Meta_removeCallback_name = "removeCallback";

const ::std::string iceC_Murmur_Meta_getUptime_name = "getUptime";

const ::std::string iceC_Murmur_Meta_getSlice_name = "getSlice";

const ::std::string iceC_Murmur_Meta_getSliceChecksums_name = "getSliceChecksums";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::MurmurException> iceC_Murmur_MurmurException_init("::Murmur::MurmurException");

}

Murmur::MurmurException::~MurmurException() throw()
{
}

::std::string
Murmur::MurmurException::ice_id() const
{
    return "::Murmur::MurmurException";
}

Murmur::MurmurException*
Murmur::MurmurException::ice_clone() const
{
    return new MurmurException(*this);
}

void
Murmur::MurmurException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::MurmurException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::MurmurException", -1, true);
    ::Ice::StreamWriter< MurmurException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Murmur::MurmurException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MurmurException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::InvalidSessionException> iceC_Murmur_InvalidSessionException_init("::Murmur::InvalidSessionException");

}

Murmur::InvalidSessionException::~InvalidSessionException() throw()
{
}

::std::string
Murmur::InvalidSessionException::ice_id() const
{
    return "::Murmur::InvalidSessionException";
}

Murmur::InvalidSessionException*
Murmur::InvalidSessionException::ice_clone() const
{
    return new InvalidSessionException(*this);
}

void
Murmur::InvalidSessionException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::InvalidSessionException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::InvalidSessionException", -1, false);
    ::Ice::StreamWriter< InvalidSessionException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::InvalidSessionException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidSessionException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::InvalidChannelException> iceC_Murmur_InvalidChannelException_init("::Murmur::InvalidChannelException");

}

Murmur::InvalidChannelException::~InvalidChannelException() throw()
{
}

::std::string
Murmur::InvalidChannelException::ice_id() const
{
    return "::Murmur::InvalidChannelException";
}

Murmur::InvalidChannelException*
Murmur::InvalidChannelException::ice_clone() const
{
    return new InvalidChannelException(*this);
}

void
Murmur::InvalidChannelException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::InvalidChannelException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::InvalidChannelException", -1, false);
    ::Ice::StreamWriter< InvalidChannelException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::InvalidChannelException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidChannelException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::InvalidServerException> iceC_Murmur_InvalidServerException_init("::Murmur::InvalidServerException");

}

Murmur::InvalidServerException::~InvalidServerException() throw()
{
}

::std::string
Murmur::InvalidServerException::ice_id() const
{
    return "::Murmur::InvalidServerException";
}

Murmur::InvalidServerException*
Murmur::InvalidServerException::ice_clone() const
{
    return new InvalidServerException(*this);
}

void
Murmur::InvalidServerException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::InvalidServerException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::InvalidServerException", -1, false);
    ::Ice::StreamWriter< InvalidServerException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::InvalidServerException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidServerException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::ServerBootedException> iceC_Murmur_ServerBootedException_init("::Murmur::ServerBootedException");

}

Murmur::ServerBootedException::~ServerBootedException() throw()
{
}

::std::string
Murmur::ServerBootedException::ice_id() const
{
    return "::Murmur::ServerBootedException";
}

Murmur::ServerBootedException*
Murmur::ServerBootedException::ice_clone() const
{
    return new ServerBootedException(*this);
}

void
Murmur::ServerBootedException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::ServerBootedException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::ServerBootedException", -1, false);
    ::Ice::StreamWriter< ServerBootedException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::ServerBootedException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerBootedException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::ServerFailureException> iceC_Murmur_ServerFailureException_init("::Murmur::ServerFailureException");

}

Murmur::ServerFailureException::~ServerFailureException() throw()
{
}

::std::string
Murmur::ServerFailureException::ice_id() const
{
    return "::Murmur::ServerFailureException";
}

Murmur::ServerFailureException*
Murmur::ServerFailureException::ice_clone() const
{
    return new ServerFailureException(*this);
}

void
Murmur::ServerFailureException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::ServerFailureException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::ServerFailureException", -1, false);
    ::Ice::StreamWriter< ServerFailureException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::ServerFailureException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerFailureException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::InvalidUserException> iceC_Murmur_InvalidUserException_init("::Murmur::InvalidUserException");

}

Murmur::InvalidUserException::~InvalidUserException() throw()
{
}

::std::string
Murmur::InvalidUserException::ice_id() const
{
    return "::Murmur::InvalidUserException";
}

Murmur::InvalidUserException*
Murmur::InvalidUserException::ice_clone() const
{
    return new InvalidUserException(*this);
}

void
Murmur::InvalidUserException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::InvalidUserException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::InvalidUserException", -1, false);
    ::Ice::StreamWriter< InvalidUserException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::InvalidUserException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidUserException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::InvalidTextureException> iceC_Murmur_InvalidTextureException_init("::Murmur::InvalidTextureException");

}

Murmur::InvalidTextureException::~InvalidTextureException() throw()
{
}

::std::string
Murmur::InvalidTextureException::ice_id() const
{
    return "::Murmur::InvalidTextureException";
}

Murmur::InvalidTextureException*
Murmur::InvalidTextureException::ice_clone() const
{
    return new InvalidTextureException(*this);
}

void
Murmur::InvalidTextureException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::InvalidTextureException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::InvalidTextureException", -1, false);
    ::Ice::StreamWriter< InvalidTextureException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::InvalidTextureException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidTextureException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::InvalidCallbackException> iceC_Murmur_InvalidCallbackException_init("::Murmur::InvalidCallbackException");

}

Murmur::InvalidCallbackException::~InvalidCallbackException() throw()
{
}

::std::string
Murmur::InvalidCallbackException::ice_id() const
{
    return "::Murmur::InvalidCallbackException";
}

Murmur::InvalidCallbackException*
Murmur::InvalidCallbackException::ice_clone() const
{
    return new InvalidCallbackException(*this);
}

void
Murmur::InvalidCallbackException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::InvalidCallbackException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::InvalidCallbackException", -1, false);
    ::Ice::StreamWriter< InvalidCallbackException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::InvalidCallbackException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidCallbackException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::InvalidSecretException> iceC_Murmur_InvalidSecretException_init("::Murmur::InvalidSecretException");

}

Murmur::InvalidSecretException::~InvalidSecretException() throw()
{
}

::std::string
Murmur::InvalidSecretException::ice_id() const
{
    return "::Murmur::InvalidSecretException";
}

Murmur::InvalidSecretException*
Murmur::InvalidSecretException::ice_clone() const
{
    return new InvalidSecretException(*this);
}

void
Murmur::InvalidSecretException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::InvalidSecretException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::InvalidSecretException", -1, false);
    ::Ice::StreamWriter< InvalidSecretException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::InvalidSecretException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidSecretException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::NestingLimitException> iceC_Murmur_NestingLimitException_init("::Murmur::NestingLimitException");

}

Murmur::NestingLimitException::~NestingLimitException() throw()
{
}

::std::string
Murmur::NestingLimitException::ice_id() const
{
    return "::Murmur::NestingLimitException";
}

Murmur::NestingLimitException*
Murmur::NestingLimitException::ice_clone() const
{
    return new NestingLimitException(*this);
}

void
Murmur::NestingLimitException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::NestingLimitException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::NestingLimitException", -1, false);
    ::Ice::StreamWriter< NestingLimitException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::NestingLimitException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< NestingLimitException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::WriteOnlyException> iceC_Murmur_WriteOnlyException_init("::Murmur::WriteOnlyException");

}

Murmur::WriteOnlyException::~WriteOnlyException() throw()
{
}

::std::string
Murmur::WriteOnlyException::ice_id() const
{
    return "::Murmur::WriteOnlyException";
}

Murmur::WriteOnlyException*
Murmur::WriteOnlyException::ice_clone() const
{
    return new WriteOnlyException(*this);
}

void
Murmur::WriteOnlyException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::WriteOnlyException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::WriteOnlyException", -1, false);
    ::Ice::StreamWriter< WriteOnlyException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::WriteOnlyException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< WriteOnlyException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Murmur::InvalidInputDataException> iceC_Murmur_InvalidInputDataException_init("::Murmur::InvalidInputDataException");

}

Murmur::InvalidInputDataException::~InvalidInputDataException() throw()
{
}

::std::string
Murmur::InvalidInputDataException::ice_id() const
{
    return "::Murmur::InvalidInputDataException";
}

Murmur::InvalidInputDataException*
Murmur::InvalidInputDataException::ice_clone() const
{
    return new InvalidInputDataException(*this);
}

void
Murmur::InvalidInputDataException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Murmur::InvalidInputDataException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Murmur::InvalidInputDataException", -1, false);
    ::Ice::StreamWriter< InvalidInputDataException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
Murmur::InvalidInputDataException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidInputDataException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

Murmur::AMD_Server_isRunning::~AMD_Server_isRunning()
{
}

Murmur::AMD_Server_start::~AMD_Server_start()
{
}

Murmur::AMD_Server_stop::~AMD_Server_stop()
{
}

Murmur::AMD_Server_delete::~AMD_Server_delete()
{
}

Murmur::AMD_Server_id::~AMD_Server_id()
{
}

Murmur::AMD_Server_addCallback::~AMD_Server_addCallback()
{
}

Murmur::AMD_Server_removeCallback::~AMD_Server_removeCallback()
{
}

Murmur::AMD_Server_setAuthenticator::~AMD_Server_setAuthenticator()
{
}

Murmur::AMD_Server_getConf::~AMD_Server_getConf()
{
}

Murmur::AMD_Server_getAllConf::~AMD_Server_getAllConf()
{
}

Murmur::AMD_Server_setConf::~AMD_Server_setConf()
{
}

Murmur::AMD_Server_setSuperuserPassword::~AMD_Server_setSuperuserPassword()
{
}

Murmur::AMD_Server_getLog::~AMD_Server_getLog()
{
}

Murmur::AMD_Server_getLogLen::~AMD_Server_getLogLen()
{
}

Murmur::AMD_Server_getUsers::~AMD_Server_getUsers()
{
}

Murmur::AMD_Server_getChannels::~AMD_Server_getChannels()
{
}

Murmur::AMD_Server_getCertificateList::~AMD_Server_getCertificateList()
{
}

Murmur::AMD_Server_getTree::~AMD_Server_getTree()
{
}

Murmur::AMD_Server_getBans::~AMD_Server_getBans()
{
}

Murmur::AMD_Server_setBans::~AMD_Server_setBans()
{
}

Murmur::AMD_Server_kickUser::~AMD_Server_kickUser()
{
}

Murmur::AMD_Server_getState::~AMD_Server_getState()
{
}

Murmur::AMD_Server_setState::~AMD_Server_setState()
{
}

Murmur::AMD_Server_sendMessage::~AMD_Server_sendMessage()
{
}

Murmur::AMD_Server_hasPermission::~AMD_Server_hasPermission()
{
}

Murmur::AMD_Server_effectivePermissions::~AMD_Server_effectivePermissions()
{
}

Murmur::AMD_Server_addContextCallback::~AMD_Server_addContextCallback()
{
}

Murmur::AMD_Server_removeContextCallback::~AMD_Server_removeContextCallback()
{
}

Murmur::AMD_Server_getChannelState::~AMD_Server_getChannelState()
{
}

Murmur::AMD_Server_setChannelState::~AMD_Server_setChannelState()
{
}

Murmur::AMD_Server_removeChannel::~AMD_Server_removeChannel()
{
}

Murmur::AMD_Server_addChannel::~AMD_Server_addChannel()
{
}

Murmur::AMD_Server_sendMessageChannel::~AMD_Server_sendMessageChannel()
{
}

Murmur::AMD_Server_getACL::~AMD_Server_getACL()
{
}

Murmur::AMD_Server_setACL::~AMD_Server_setACL()
{
}

Murmur::AMD_Server_addUserToGroup::~AMD_Server_addUserToGroup()
{
}

Murmur::AMD_Server_removeUserFromGroup::~AMD_Server_removeUserFromGroup()
{
}

Murmur::AMD_Server_redirectWhisperGroup::~AMD_Server_redirectWhisperGroup()
{
}

Murmur::AMD_Server_getUserNames::~AMD_Server_getUserNames()
{
}

Murmur::AMD_Server_getUserIds::~AMD_Server_getUserIds()
{
}

Murmur::AMD_Server_registerUser::~AMD_Server_registerUser()
{
}

Murmur::AMD_Server_unregisterUser::~AMD_Server_unregisterUser()
{
}

Murmur::AMD_Server_updateRegistration::~AMD_Server_updateRegistration()
{
}

Murmur::AMD_Server_getRegistration::~AMD_Server_getRegistration()
{
}

Murmur::AMD_Server_getRegisteredUsers::~AMD_Server_getRegisteredUsers()
{
}

Murmur::AMD_Server_verifyPassword::~AMD_Server_verifyPassword()
{
}

Murmur::AMD_Server_getTexture::~AMD_Server_getTexture()
{
}

Murmur::AMD_Server_setTexture::~AMD_Server_setTexture()
{
}

Murmur::AMD_Server_getUptime::~AMD_Server_getUptime()
{
}

Murmur::AMD_Server_updateCertificate::~AMD_Server_updateCertificate()
{
}

Murmur::AMD_Server_startListening::~AMD_Server_startListening()
{
}

Murmur::AMD_Server_stopListening::~AMD_Server_stopListening()
{
}

Murmur::AMD_Server_isListening::~AMD_Server_isListening()
{
}

Murmur::AMD_Server_getListeningChannels::~AMD_Server_getListeningChannels()
{
}

Murmur::AMD_Server_getListeningUsers::~AMD_Server_getListeningUsers()
{
}

Murmur::AMD_Server_sendWelcomeMessage::~AMD_Server_sendWelcomeMessage()
{
}

Murmur::AMD_Meta_getServer::~AMD_Meta_getServer()
{
}

Murmur::AMD_Meta_newServer::~AMD_Meta_newServer()
{
}

Murmur::AMD_Meta_getBootedServers::~AMD_Meta_getBootedServers()
{
}

Murmur::AMD_Meta_getAllServers::~AMD_Meta_getAllServers()
{
}

Murmur::AMD_Meta_getDefaultConf::~AMD_Meta_getDefaultConf()
{
}

Murmur::AMD_Meta_getVersion::~AMD_Meta_getVersion()
{
}

Murmur::AMD_Meta_addCallback::~AMD_Meta_addCallback()
{
}

Murmur::AMD_Meta_removeCallback::~AMD_Meta_removeCallback()
{
}

Murmur::AMD_Meta_getUptime::~AMD_Meta_getUptime()
{
}

Murmur::AMD_Meta_getSlice::~AMD_Meta_getSlice()
{
}

Murmur::AMD_Meta_getSliceChecksums::~AMD_Meta_getSliceChecksums()
{
}

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_isRunning::AMD_Server_isRunning(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_isRunning::ice_response(bool ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_start::AMD_Server_start(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_start::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_stop::AMD_Server_stop(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_stop::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_delete::AMD_Server_delete(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_delete::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_id::AMD_Server_id(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_id::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_addCallback::AMD_Server_addCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_addCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_removeCallback::AMD_Server_removeCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_removeCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_setAuthenticator::AMD_Server_setAuthenticator(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setAuthenticator::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getConf::AMD_Server_getConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getConf::ice_response(const ::std::string& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getAllConf::AMD_Server_getAllConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getAllConf::ice_response(const ::Murmur::ConfigMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_setConf::AMD_Server_setConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setConf::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_setSuperuserPassword::AMD_Server_setSuperuserPassword(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setSuperuserPassword::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getLog::AMD_Server_getLog(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getLog::ice_response(const ::Murmur::LogList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getLogLen::AMD_Server_getLogLen(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getLogLen::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getUsers::AMD_Server_getUsers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getUsers::ice_response(const ::Murmur::UserMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getChannels::AMD_Server_getChannels(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getChannels::ice_response(const ::Murmur::ChannelMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getCertificateList::AMD_Server_getCertificateList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getCertificateList::ice_response(const ::Murmur::CertificateList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getTree::AMD_Server_getTree(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getTree::ice_response(const ::Murmur::TreePtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getBans::AMD_Server_getBans(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getBans::ice_response(const ::Murmur::BanList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_setBans::AMD_Server_setBans(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setBans::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_kickUser::AMD_Server_kickUser(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_kickUser::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getState::AMD_Server_getState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getState::ice_response(const ::Murmur::User& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_setState::AMD_Server_setState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setState::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_sendMessage::AMD_Server_sendMessage(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_sendMessage::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_hasPermission::AMD_Server_hasPermission(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_hasPermission::ice_response(bool ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_effectivePermissions::AMD_Server_effectivePermissions(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_effectivePermissions::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_addContextCallback::AMD_Server_addContextCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_addContextCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_removeContextCallback::AMD_Server_removeContextCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_removeContextCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getChannelState::AMD_Server_getChannelState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getChannelState::ice_response(const ::Murmur::Channel& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_setChannelState::AMD_Server_setChannelState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setChannelState::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_removeChannel::AMD_Server_removeChannel(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_removeChannel::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_addChannel::AMD_Server_addChannel(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_addChannel::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_sendMessageChannel::AMD_Server_sendMessageChannel(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_sendMessageChannel::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getACL::AMD_Server_getACL(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getACL::ice_response(const ::Murmur::ACLList& acls, const ::Murmur::GroupList& groups, bool inherit)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(acls);
    ostr->write(groups);
    ostr->write(inherit);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_setACL::AMD_Server_setACL(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setACL::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_addUserToGroup::AMD_Server_addUserToGroup(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_addUserToGroup::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_removeUserFromGroup::AMD_Server_removeUserFromGroup(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_removeUserFromGroup::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_redirectWhisperGroup::AMD_Server_redirectWhisperGroup(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_redirectWhisperGroup::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getUserNames::AMD_Server_getUserNames(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getUserNames::ice_response(const ::Murmur::NameMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getUserIds::AMD_Server_getUserIds(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getUserIds::ice_response(const ::Murmur::IdMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_registerUser::AMD_Server_registerUser(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_registerUser::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_unregisterUser::AMD_Server_unregisterUser(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_unregisterUser::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_updateRegistration::AMD_Server_updateRegistration(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_updateRegistration::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getRegistration::AMD_Server_getRegistration(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getRegistration::ice_response(const ::Murmur::UserInfoMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getRegisteredUsers::AMD_Server_getRegisteredUsers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getRegisteredUsers::ice_response(const ::Murmur::NameMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_verifyPassword::AMD_Server_verifyPassword(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_verifyPassword::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getTexture::AMD_Server_getTexture(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getTexture::ice_response(const ::Murmur::Texture& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_setTexture::AMD_Server_setTexture(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_setTexture::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getUptime::AMD_Server_getUptime(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getUptime::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_updateCertificate::AMD_Server_updateCertificate(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_updateCertificate::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_startListening::AMD_Server_startListening(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_startListening::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_stopListening::AMD_Server_stopListening(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_stopListening::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_isListening::AMD_Server_isListening(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_isListening::ice_response(bool ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getListeningChannels::AMD_Server_getListeningChannels(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getListeningChannels::ice_response(const ::Murmur::IntList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_getListeningUsers::AMD_Server_getListeningUsers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_getListeningUsers::ice_response(const ::Murmur::IntList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Server_sendWelcomeMessage::AMD_Server_sendWelcomeMessage(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Server_sendWelcomeMessage::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_getServer::AMD_Meta_getServer(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getServer::ice_response(const ::Murmur::ServerPrx& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_newServer::AMD_Meta_newServer(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_newServer::ice_response(const ::Murmur::ServerPrx& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_getBootedServers::AMD_Meta_getBootedServers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getBootedServers::ice_response(const ::Murmur::ServerList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_getAllServers::AMD_Meta_getAllServers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getAllServers::ice_response(const ::Murmur::ServerList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_getDefaultConf::AMD_Meta_getDefaultConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getDefaultConf::ice_response(const ::Murmur::ConfigMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_getVersion::AMD_Meta_getVersion(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getVersion::ice_response(::Ice::Int major, ::Ice::Int minor, ::Ice::Int patch, const ::std::string& text)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(major);
    ostr->write(minor);
    ostr->write(patch);
    ostr->write(text);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_addCallback::AMD_Meta_addCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_addCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_removeCallback::AMD_Meta_removeCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_removeCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_getUptime::AMD_Meta_getUptime(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getUptime::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_getSlice::AMD_Meta_getSlice(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getSlice::ice_response(const ::std::string& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Murmur::AMD_Meta_getSliceChecksums::AMD_Meta_getSliceChecksums(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Murmur::AMD_Meta_getSliceChecksums::ice_response(const ::Ice::SliceChecksumDict& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(Tree* p) { return p; }

void
::IceProxy::Murmur::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Tree>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Tree;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Murmur::Tree::_newInstance() const
{
    return new Tree;
}
/// \endcond

const ::std::string&
IceProxy::Murmur::Tree::ice_staticId()
{
    return ::Murmur::Tree::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(ServerCallback* p) { return p; }

void
::IceProxy::Murmur::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ServerCallback>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ServerCallback;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::_iceI_begin_userConnected(const ::Murmur::User& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerCallback_userConnected_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerCallback_userConnected_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerCallback_userConnected_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::ServerCallback::end_userConnected(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_ServerCallback_userConnected_name);
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::_iceI_begin_userDisconnected(const ::Murmur::User& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerCallback_userDisconnected_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerCallback_userDisconnected_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerCallback_userDisconnected_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::ServerCallback::end_userDisconnected(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_ServerCallback_userDisconnected_name);
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::_iceI_begin_userStateChanged(const ::Murmur::User& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerCallback_userStateChanged_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerCallback_userStateChanged_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerCallback_userStateChanged_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::ServerCallback::end_userStateChanged(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_ServerCallback_userStateChanged_name);
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::_iceI_begin_userTextMessage(const ::Murmur::User& iceP_state, const ::Murmur::TextMessage& iceP_message, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerCallback_userTextMessage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerCallback_userTextMessage_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        ostr->write(iceP_message);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerCallback_userTextMessage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::ServerCallback::end_userTextMessage(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_ServerCallback_userTextMessage_name);
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::_iceI_begin_channelCreated(const ::Murmur::Channel& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerCallback_channelCreated_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerCallback_channelCreated_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerCallback_channelCreated_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::ServerCallback::end_channelCreated(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_ServerCallback_channelCreated_name);
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::_iceI_begin_channelRemoved(const ::Murmur::Channel& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerCallback_channelRemoved_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerCallback_channelRemoved_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerCallback_channelRemoved_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::ServerCallback::end_channelRemoved(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_ServerCallback_channelRemoved_name);
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerCallback::_iceI_begin_channelStateChanged(const ::Murmur::Channel& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerCallback_channelStateChanged_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerCallback_channelStateChanged_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerCallback_channelStateChanged_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::ServerCallback::end_channelStateChanged(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_ServerCallback_channelStateChanged_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Murmur::ServerCallback::_newInstance() const
{
    return new ServerCallback;
}
/// \endcond

const ::std::string&
IceProxy::Murmur::ServerCallback::ice_staticId()
{
    return ::Murmur::ServerCallback::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(ServerContextCallback* p) { return p; }

void
::IceProxy::Murmur::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ServerContextCallback>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ServerContextCallback;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerContextCallback::_iceI_begin_contextAction(const ::std::string& iceP_action, const ::Murmur::User& iceP_usr, ::Ice::Int iceP_session, ::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerContextCallback_contextAction_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerContextCallback_contextAction_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_action);
        ostr->write(iceP_usr);
        ostr->write(iceP_session);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerContextCallback_contextAction_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::ServerContextCallback::end_contextAction(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_ServerContextCallback_contextAction_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Murmur::ServerContextCallback::_newInstance() const
{
    return new ServerContextCallback;
}
/// \endcond

const ::std::string&
IceProxy::Murmur::ServerContextCallback::ice_staticId()
{
    return ::Murmur::ServerContextCallback::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(ServerAuthenticator* p) { return p; }

void
::IceProxy::Murmur::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ServerAuthenticator>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ServerAuthenticator;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerAuthenticator::_iceI_begin_authenticate(const ::std::string& iceP_name, const ::std::string& iceP_pw, const ::Murmur::CertificateList& iceP_certificates, const ::std::string& iceP_certhash, bool iceP_certstrong, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_ServerAuthenticator_authenticate_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerAuthenticator_authenticate_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerAuthenticator_authenticate_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_pw);
        ostr->write(iceP_certificates);
        ostr->write(iceP_certhash);
        ostr->write(iceP_certstrong);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerAuthenticator_authenticate_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::ServerAuthenticator::end_authenticate(::std::string& iceP_newname, ::Murmur::GroupNameList& iceP_groups, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerAuthenticator_authenticate_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_newname);
    istr->read(iceP_groups);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Murmur::ServerAuthenticator::_iceI_end_authenticate(::std::string& iceP_newname, ::Murmur::GroupNameList& iceP_groups, ::Ice::Int& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerAuthenticator_authenticate_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_newname);
    istr->read(iceP_groups);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerAuthenticator::_iceI_begin_getInfo(::Ice::Int iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_ServerAuthenticator_getInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerAuthenticator_getInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerAuthenticator_getInfo_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerAuthenticator_getInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::Murmur::ServerAuthenticator::end_getInfo(::Murmur::UserInfoMap& iceP_info, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerAuthenticator_getInfo_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_info);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Murmur::ServerAuthenticator::_iceI_end_getInfo(::Murmur::UserInfoMap& iceP_info, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerAuthenticator_getInfo_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_info);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerAuthenticator::_iceI_begin_nameToId(const ::std::string& iceP_name, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_ServerAuthenticator_nameToId_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerAuthenticator_nameToId_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerAuthenticator_nameToId_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerAuthenticator_nameToId_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::ServerAuthenticator::end_nameToId(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerAuthenticator_nameToId_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerAuthenticator::_iceI_begin_idToName(::Ice::Int iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_ServerAuthenticator_idToName_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerAuthenticator_idToName_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerAuthenticator_idToName_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerAuthenticator_idToName_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::Murmur::ServerAuthenticator::end_idToName(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerAuthenticator_idToName_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerAuthenticator::_iceI_begin_idToTexture(::Ice::Int iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_ServerAuthenticator_idToTexture_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerAuthenticator_idToTexture_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerAuthenticator_idToTexture_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerAuthenticator_idToTexture_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::Texture
IceProxy::Murmur::ServerAuthenticator::end_idToTexture(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerAuthenticator_idToTexture_name);
    ::Murmur::Texture ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Murmur::ServerAuthenticator::_newInstance() const
{
    return new ServerAuthenticator;
}
/// \endcond

const ::std::string&
IceProxy::Murmur::ServerAuthenticator::ice_staticId()
{
    return ::Murmur::ServerAuthenticator::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(ServerUpdatingAuthenticator* p) { return p; }

void
::IceProxy::Murmur::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ServerUpdatingAuthenticator>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ServerUpdatingAuthenticator;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerUpdatingAuthenticator::_iceI_begin_registerUser(const ::Murmur::UserInfoMap& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_ServerUpdatingAuthenticator_registerUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerUpdatingAuthenticator_registerUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerUpdatingAuthenticator_registerUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerUpdatingAuthenticator_registerUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::end_registerUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerUpdatingAuthenticator_registerUser_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerUpdatingAuthenticator::_iceI_begin_unregisterUser(::Ice::Int iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_ServerUpdatingAuthenticator_unregisterUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerUpdatingAuthenticator_unregisterUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerUpdatingAuthenticator_unregisterUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerUpdatingAuthenticator_unregisterUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::end_unregisterUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerUpdatingAuthenticator_unregisterUser_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerUpdatingAuthenticator::_iceI_begin_getRegisteredUsers(const ::std::string& iceP_filter, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_ServerUpdatingAuthenticator_getRegisteredUsers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerUpdatingAuthenticator_getRegisteredUsers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerUpdatingAuthenticator_getRegisteredUsers_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_filter);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerUpdatingAuthenticator_getRegisteredUsers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::NameMap
IceProxy::Murmur::ServerUpdatingAuthenticator::end_getRegisteredUsers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerUpdatingAuthenticator_getRegisteredUsers_name);
    ::Murmur::NameMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerUpdatingAuthenticator::_iceI_begin_setInfo(::Ice::Int iceP_id, const ::Murmur::UserInfoMap& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_ServerUpdatingAuthenticator_setInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerUpdatingAuthenticator_setInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerUpdatingAuthenticator_setInfo_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerUpdatingAuthenticator_setInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::end_setInfo(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerUpdatingAuthenticator_setInfo_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::ServerUpdatingAuthenticator::_iceI_begin_setTexture(::Ice::Int iceP_id, const ::Murmur::Texture& iceP_tex, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_ServerUpdatingAuthenticator_setTexture_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_ServerUpdatingAuthenticator_setTexture_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_ServerUpdatingAuthenticator_setTexture_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        ostr->write(iceP_tex);
        result->endWriteParams();
        result->invoke(iceC_Murmur_ServerUpdatingAuthenticator_setTexture_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::ServerUpdatingAuthenticator::end_setTexture(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_ServerUpdatingAuthenticator_setTexture_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Murmur::ServerUpdatingAuthenticator::_newInstance() const
{
    return new ServerUpdatingAuthenticator;
}
/// \endcond

const ::std::string&
IceProxy::Murmur::ServerUpdatingAuthenticator::ice_staticId()
{
    return ::Murmur::ServerUpdatingAuthenticator::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(Server* p) { return p; }

void
::IceProxy::Murmur::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Server>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Server;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_isRunning(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_isRunning_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_isRunning_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_isRunning_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_isRunning_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::Murmur::Server::end_isRunning(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_isRunning_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_start(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_start_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_start_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_start_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_start_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_start(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_start_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerFailureException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_stop(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_stop_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_stop_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_stop_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_stop_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_stop(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_stop_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_delete(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_delete_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_delete_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_delete_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_delete_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_delete(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_delete_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_id(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_id_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_id_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_id_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_id_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::Server::end_id(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_id_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_addCallback(const ::Murmur::ServerCallbackPrx& iceP_cb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_addCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_addCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_addCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cb);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_addCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_addCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_addCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_removeCallback(const ::Murmur::ServerCallbackPrx& iceP_cb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_removeCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_removeCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_removeCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cb);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_removeCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_removeCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_removeCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_setAuthenticator(const ::Murmur::ServerAuthenticatorPrx& iceP_auth, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_setAuthenticator_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_setAuthenticator_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_setAuthenticator_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_auth);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_setAuthenticator_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_setAuthenticator(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_setAuthenticator_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getConf(const ::std::string& iceP_key, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getConf_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getConf_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getConf_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_key);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getConf_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::Murmur::Server::end_getConf(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getConf_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::WriteOnlyException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getAllConf(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getAllConf_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getAllConf_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getAllConf_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_getAllConf_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::ConfigMap
IceProxy::Murmur::Server::end_getAllConf(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getAllConf_name);
    ::Murmur::ConfigMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_setConf(const ::std::string& iceP_key, const ::std::string& iceP_value, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_setConf_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_setConf_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_setConf_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_key);
        ostr->write(iceP_value);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_setConf_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_setConf(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_setConf_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_setSuperuserPassword(const ::std::string& iceP_pw, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_setSuperuserPassword_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_setSuperuserPassword_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_setSuperuserPassword_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_pw);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_setSuperuserPassword_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_setSuperuserPassword(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_setSuperuserPassword_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getLog(::Ice::Int iceP_first, ::Ice::Int iceP_last, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getLog_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getLog_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getLog_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_first);
        ostr->write(iceP_last);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getLog_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::LogList
IceProxy::Murmur::Server::end_getLog(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getLog_name);
    ::Murmur::LogList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getLogLen(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getLogLen_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getLogLen_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getLogLen_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_getLogLen_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::Server::end_getLogLen(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getLogLen_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getUsers(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getUsers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getUsers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getUsers_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_getUsers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::UserMap
IceProxy::Murmur::Server::end_getUsers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getUsers_name);
    ::Murmur::UserMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getChannels(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getChannels_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getChannels_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getChannels_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_getChannels_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::ChannelMap
IceProxy::Murmur::Server::end_getChannels(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getChannels_name);
    ::Murmur::ChannelMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getCertificateList(::Ice::Int iceP_session, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getCertificateList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getCertificateList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getCertificateList_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getCertificateList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::CertificateList
IceProxy::Murmur::Server::end_getCertificateList(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getCertificateList_name);
    ::Murmur::CertificateList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getTree(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getTree_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getTree_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getTree_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_getTree_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::TreePtr
IceProxy::Murmur::Server::end_getTree(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getTree_name);
    ::Murmur::TreePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getBans(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getBans_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getBans_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getBans_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_getBans_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::BanList
IceProxy::Murmur::Server::end_getBans(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getBans_name);
    ::Murmur::BanList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_setBans(const ::Murmur::BanList& iceP_bans, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_setBans_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_setBans_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_setBans_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_bans);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_setBans_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_setBans(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_setBans_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_kickUser(::Ice::Int iceP_session, const ::std::string& iceP_reason, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_kickUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_kickUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_kickUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_reason);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_kickUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_kickUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_kickUser_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getState(::Ice::Int iceP_session, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getState_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getState_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getState_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getState_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::User
IceProxy::Murmur::Server::end_getState(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getState_name);
    ::Murmur::User ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_setState(const ::Murmur::User& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_setState_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_setState_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_setState_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_setState_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_setState(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_setState_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_sendMessage(::Ice::Int iceP_session, const ::std::string& iceP_text, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_sendMessage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_sendMessage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_sendMessage_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_text);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_sendMessage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_sendMessage(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_sendMessage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_hasPermission(::Ice::Int iceP_session, ::Ice::Int iceP_channelid, ::Ice::Int iceP_perm, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_hasPermission_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_hasPermission_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_hasPermission_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_channelid);
        ostr->write(iceP_perm);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_hasPermission_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::Murmur::Server::end_hasPermission(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_hasPermission_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_effectivePermissions(::Ice::Int iceP_session, ::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_effectivePermissions_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_effectivePermissions_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_effectivePermissions_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_effectivePermissions_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::Server::end_effectivePermissions(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_effectivePermissions_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_addContextCallback(::Ice::Int iceP_session, const ::std::string& iceP_action, const ::std::string& iceP_text, const ::Murmur::ServerContextCallbackPrx& iceP_cb, ::Ice::Int iceP_ctx, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_addContextCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_addContextCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_addContextCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_action);
        ostr->write(iceP_text);
        ostr->write(iceP_cb);
        ostr->write(iceP_ctx);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_addContextCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_addContextCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_addContextCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_removeContextCallback(const ::Murmur::ServerContextCallbackPrx& iceP_cb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_removeContextCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_removeContextCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_removeContextCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cb);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_removeContextCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_removeContextCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_removeContextCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getChannelState(::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getChannelState_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getChannelState_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getChannelState_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getChannelState_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::Channel
IceProxy::Murmur::Server::end_getChannelState(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getChannelState_name);
    ::Murmur::Channel ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_setChannelState(const ::Murmur::Channel& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_setChannelState_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_setChannelState_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_setChannelState_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_setChannelState_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_setChannelState(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_setChannelState_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::NestingLimitException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_removeChannel(::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_removeChannel_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_removeChannel_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_removeChannel_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_removeChannel_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_removeChannel(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_removeChannel_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_addChannel(const ::std::string& iceP_name, ::Ice::Int iceP_parent, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_addChannel_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_addChannel_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_addChannel_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_parent);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_addChannel_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::Server::end_addChannel(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_addChannel_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::NestingLimitException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_sendMessageChannel(::Ice::Int iceP_channelid, bool iceP_tree, const ::std::string& iceP_text, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_sendMessageChannel_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_sendMessageChannel_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_sendMessageChannel_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        ostr->write(iceP_tree);
        ostr->write(iceP_text);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_sendMessageChannel_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_sendMessageChannel(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_sendMessageChannel_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getACL(::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getACL_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getACL_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getACL_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getACL_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_getACL(::Murmur::ACLList& iceP_acls, ::Murmur::GroupList& iceP_groups, bool& iceP_inherit, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getACL_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_acls);
    istr->read(iceP_groups);
    istr->read(iceP_inherit);
    result->_endReadParams();
}

void IceProxy::Murmur::Server::_iceI_end_getACL(::Murmur::ACLList& iceP_acls, ::Murmur::GroupList& iceP_groups, bool& iceP_inherit, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getACL_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_acls);
    istr->read(iceP_groups);
    istr->read(iceP_inherit);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_setACL(::Ice::Int iceP_channelid, const ::Murmur::ACLList& iceP_acls, const ::Murmur::GroupList& iceP_groups, bool iceP_inherit, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_setACL_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_setACL_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_setACL_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        ostr->write(iceP_acls);
        ostr->write(iceP_groups);
        ostr->write(iceP_inherit);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_setACL_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_setACL(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_setACL_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_addUserToGroup(::Ice::Int iceP_channelid, ::Ice::Int iceP_session, const ::std::string& iceP_group, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_addUserToGroup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_addUserToGroup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_addUserToGroup_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        ostr->write(iceP_session);
        ostr->write(iceP_group);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_addUserToGroup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_addUserToGroup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_addUserToGroup_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_removeUserFromGroup(::Ice::Int iceP_channelid, ::Ice::Int iceP_session, const ::std::string& iceP_group, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_removeUserFromGroup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_removeUserFromGroup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_removeUserFromGroup_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        ostr->write(iceP_session);
        ostr->write(iceP_group);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_removeUserFromGroup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_removeUserFromGroup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_removeUserFromGroup_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_redirectWhisperGroup(::Ice::Int iceP_session, const ::std::string& iceP_source, const ::std::string& iceP_target, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_redirectWhisperGroup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_redirectWhisperGroup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_redirectWhisperGroup_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_source);
        ostr->write(iceP_target);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_redirectWhisperGroup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_redirectWhisperGroup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_redirectWhisperGroup_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getUserNames(const ::Murmur::IdList& iceP_ids, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getUserNames_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getUserNames_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getUserNames_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_ids);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getUserNames_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::NameMap
IceProxy::Murmur::Server::end_getUserNames(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getUserNames_name);
    ::Murmur::NameMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getUserIds(const ::Murmur::NameList& iceP_names, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getUserIds_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getUserIds_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getUserIds_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_names);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getUserIds_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::IdMap
IceProxy::Murmur::Server::end_getUserIds(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getUserIds_name);
    ::Murmur::IdMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_registerUser(const ::Murmur::UserInfoMap& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_registerUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_registerUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_registerUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_registerUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::Server::end_registerUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_registerUser_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidUserException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_unregisterUser(::Ice::Int iceP_userid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_unregisterUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_unregisterUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_unregisterUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_unregisterUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_unregisterUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_unregisterUser_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidUserException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_updateRegistration(::Ice::Int iceP_userid, const ::Murmur::UserInfoMap& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_updateRegistration_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_updateRegistration_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_updateRegistration_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_updateRegistration_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_updateRegistration(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_updateRegistration_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidUserException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getRegistration(::Ice::Int iceP_userid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getRegistration_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getRegistration_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getRegistration_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getRegistration_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::UserInfoMap
IceProxy::Murmur::Server::end_getRegistration(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getRegistration_name);
    ::Murmur::UserInfoMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidUserException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getRegisteredUsers(const ::std::string& iceP_filter, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getRegisteredUsers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getRegisteredUsers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getRegisteredUsers_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_filter);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getRegisteredUsers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::NameMap
IceProxy::Murmur::Server::end_getRegisteredUsers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getRegisteredUsers_name);
    ::Murmur::NameMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_verifyPassword(const ::std::string& iceP_name, const ::std::string& iceP_pw, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_verifyPassword_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_verifyPassword_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_verifyPassword_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_pw);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_verifyPassword_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::Server::end_verifyPassword(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_verifyPassword_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getTexture(::Ice::Int iceP_userid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getTexture_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getTexture_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getTexture_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getTexture_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::Texture
IceProxy::Murmur::Server::end_getTexture(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getTexture_name);
    ::Murmur::Texture ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidUserException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_setTexture(::Ice::Int iceP_userid, const ::Murmur::Texture& iceP_tex, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_setTexture_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_setTexture_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_setTexture_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        ostr->write(iceP_tex);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_setTexture_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_setTexture(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_setTexture_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidTextureException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidUserException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getUptime(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getUptime_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getUptime_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getUptime_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Server_getUptime_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::Server::end_getUptime(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getUptime_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_updateCertificate(const ::std::string& iceP_certificate, const ::std::string& iceP_privateKey, const ::std::string& iceP_passphrase, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_updateCertificate_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_updateCertificate_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_updateCertificate_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_certificate);
        ostr->write(iceP_privateKey);
        ostr->write(iceP_passphrase);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_updateCertificate_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_updateCertificate(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_updateCertificate_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidInputDataException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Murmur::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_startListening(::Ice::Int iceP_userid, ::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_startListening_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_startListening_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_startListening_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_startListening(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_Server_startListening_name);
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_stopListening(::Ice::Int iceP_userid, ::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_stopListening_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_stopListening_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_stopListening_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_stopListening(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_Server_stopListening_name);
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_isListening(::Ice::Int iceP_userid, ::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_isListening_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_isListening_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_isListening_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_isListening_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::Murmur::Server::end_isListening(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_isListening_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getListeningChannels(::Ice::Int iceP_userid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getListeningChannels_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getListeningChannels_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getListeningChannels_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getListeningChannels_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::IntList
IceProxy::Murmur::Server::end_getListeningChannels(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getListeningChannels_name);
    ::Murmur::IntList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_getListeningUsers(::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Server_getListeningUsers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_getListeningUsers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_getListeningUsers_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_getListeningUsers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::IntList
IceProxy::Murmur::Server::end_getListeningUsers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Server_getListeningUsers_name);
    ::Murmur::IntList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Server::_iceI_begin_sendWelcomeMessage(const ::Murmur::IdList& iceP_receiverUserIDs, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Server_sendWelcomeMessage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Server_sendWelcomeMessage_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_receiverUserIDs);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Server_sendWelcomeMessage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Server::end_sendWelcomeMessage(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_Server_sendWelcomeMessage_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Murmur::Server::_newInstance() const
{
    return new Server;
}
/// \endcond

const ::std::string&
IceProxy::Murmur::Server::ice_staticId()
{
    return ::Murmur::Server::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(MetaCallback* p) { return p; }

void
::IceProxy::Murmur::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< MetaCallback>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new MetaCallback;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Murmur::MetaCallback::_iceI_begin_started(const ::Murmur::ServerPrx& iceP_srv, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_MetaCallback_started_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_MetaCallback_started_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_srv);
        result->endWriteParams();
        result->invoke(iceC_Murmur_MetaCallback_started_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::MetaCallback::end_started(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_MetaCallback_started_name);
}

::Ice::AsyncResultPtr
IceProxy::Murmur::MetaCallback::_iceI_begin_stopped(const ::Murmur::ServerPrx& iceP_srv, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_MetaCallback_stopped_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_MetaCallback_stopped_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_srv);
        result->endWriteParams();
        result->invoke(iceC_Murmur_MetaCallback_stopped_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::MetaCallback::end_stopped(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Murmur_MetaCallback_stopped_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Murmur::MetaCallback::_newInstance() const
{
    return new MetaCallback;
}
/// \endcond

const ::std::string&
IceProxy::Murmur::MetaCallback::ice_staticId()
{
    return ::Murmur::MetaCallback::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Murmur::upCast(Meta* p) { return p; }

void
::IceProxy::Murmur::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Meta>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Meta;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_getServer(::Ice::Int iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getServer_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_getServer_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_getServer_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Meta_getServer_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::ServerPrx
IceProxy::Murmur::Meta::end_getServer(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_getServer_name);
    ::Murmur::ServerPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_newServer(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_newServer_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_newServer_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_newServer_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Meta_newServer_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::ServerPrx
IceProxy::Murmur::Meta::end_newServer(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_newServer_name);
    ::Murmur::ServerPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_getBootedServers(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getBootedServers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_getBootedServers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_getBootedServers_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Meta_getBootedServers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::ServerList
IceProxy::Murmur::Meta::end_getBootedServers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_getBootedServers_name);
    ::Murmur::ServerList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_getAllServers(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getAllServers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_getAllServers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_getAllServers_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Meta_getAllServers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::ServerList
IceProxy::Murmur::Meta::end_getAllServers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_getAllServers_name);
    ::Murmur::ServerList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_getDefaultConf(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getDefaultConf_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_getDefaultConf_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_getDefaultConf_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Meta_getDefaultConf_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Murmur::ConfigMap
IceProxy::Murmur::Meta::end_getDefaultConf(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_getDefaultConf_name);
    ::Murmur::ConfigMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_getVersion(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getVersion_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_getVersion_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_getVersion_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Meta_getVersion_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Meta::end_getVersion(::Ice::Int& iceP_major, ::Ice::Int& iceP_minor, ::Ice::Int& iceP_patch, ::std::string& iceP_text, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_getVersion_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_major);
    istr->read(iceP_minor);
    istr->read(iceP_patch);
    istr->read(iceP_text);
    result->_endReadParams();
}

void IceProxy::Murmur::Meta::_iceI_end_getVersion(::Ice::Int& iceP_major, ::Ice::Int& iceP_minor, ::Ice::Int& iceP_patch, ::std::string& iceP_text, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_getVersion_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_major);
    istr->read(iceP_minor);
    istr->read(iceP_patch);
    istr->read(iceP_text);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_addCallback(const ::Murmur::MetaCallbackPrx& iceP_cb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_addCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_addCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_addCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cb);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Meta_addCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Meta::end_addCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_addCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_removeCallback(const ::Murmur::MetaCallbackPrx& iceP_cb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_removeCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_removeCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_removeCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cb);
        result->endWriteParams();
        result->invoke(iceC_Murmur_Meta_removeCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Murmur::Meta::end_removeCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_removeCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Murmur::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::Murmur::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_getUptime(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getUptime_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_getUptime_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_getUptime_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Meta_getUptime_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Murmur::Meta::end_getUptime(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_getUptime_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_getSlice(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getSlice_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_getSlice_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_getSlice_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Meta_getSlice_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::Murmur::Meta::end_getSlice(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_getSlice_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Murmur::Meta::_iceI_begin_getSliceChecksums(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Murmur_Meta_getSliceChecksums_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Murmur_Meta_getSliceChecksums_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Murmur_Meta_getSliceChecksums_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Murmur_Meta_getSliceChecksums_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::SliceChecksumDict
IceProxy::Murmur::Meta::end_getSliceChecksums(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Murmur_Meta_getSliceChecksums_name);
    ::Ice::SliceChecksumDict ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Murmur::Meta::_newInstance() const
{
    return new Meta;
}
/// \endcond

const ::std::string&
IceProxy::Murmur::Meta::ice_staticId()
{
    return ::Murmur::Meta::ice_staticId();
}

Murmur::Tree::~Tree()
{
}

/// \cond INTERNAL
::Ice::Object* Murmur::upCast(Tree* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Murmur::Tree::ice_clone() const
{
    ::Ice::Object* p = new Tree(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Murmur_Tree_ids[2] =
{
    "::Ice::Object",
    "::Murmur::Tree"
};

}

bool
Murmur::Tree::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_Tree_ids, iceC_Murmur_Tree_ids + 2, s);
}

::std::vector< ::std::string>
Murmur::Tree::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Murmur_Tree_ids[0], &iceC_Murmur_Tree_ids[2]);
}

const ::std::string&
Murmur::Tree::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::Tree::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Murmur::Tree";
    return typeId;
#else
    return iceC_Murmur_Tree_ids[1];
#endif
}

void
Murmur::Tree::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    {
        for(::Murmur::TreeList::iterator _i0 = children.begin(); _i0 != children.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::Murmur::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

/// \cond STREAM
void
Murmur::Tree::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Tree, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Murmur::Tree::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Tree, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Murmur::Tree> iceC_Murmur_Tree_init("::Murmur::Tree");
}

::Ice::ValueFactoryPtr
Murmur::Tree::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Murmur::Tree::ice_staticId());
}

/// \cond INTERNAL
void
Murmur::_icePatchObjectPtr(TreePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = TreePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Tree::ice_staticId(), v);
    }
}
/// \endcond

Murmur::ServerCallback::~ServerCallback()
{
}

/// \cond INTERNAL
::Ice::Object* Murmur::upCast(ServerCallback* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Murmur_ServerCallback_ids[2] =
{
    "::Ice::Object",
    "::Murmur::ServerCallback"
};

}

bool
Murmur::ServerCallback::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_ServerCallback_ids, iceC_Murmur_ServerCallback_ids + 2, s);
}

::std::vector< ::std::string>
Murmur::ServerCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Murmur_ServerCallback_ids[0], &iceC_Murmur_ServerCallback_ids[2]);
}

const ::std::string&
Murmur::ServerCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::ServerCallback::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Murmur::ServerCallback";
    return typeId;
#else
    return iceC_Murmur_ServerCallback_ids[1];
#endif
}

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_userConnected(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    User iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->userConnected(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_userDisconnected(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    User iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->userDisconnected(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_userStateChanged(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    User iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->userStateChanged(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_userTextMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    User iceP_state;
    TextMessage iceP_message;
    istr->read(iceP_state);
    istr->read(iceP_message);
    inS.endReadParams();
    this->userTextMessage(iceP_state, iceP_message, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_channelCreated(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Channel iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->channelCreated(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_channelRemoved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Channel iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->channelRemoved(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceD_channelStateChanged(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Channel iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->channelStateChanged(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Murmur_ServerCallback_all[] =
{
    "channelCreated",
    "channelRemoved",
    "channelStateChanged",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "userConnected",
    "userDisconnected",
    "userStateChanged",
    "userTextMessage"
};

}

/// \cond INTERNAL
bool
Murmur::ServerCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_ServerCallback_all, iceC_Murmur_ServerCallback_all + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_ServerCallback_all)
    {
        case 0:
        {
            return _iceD_channelCreated(in, current);
        }
        case 1:
        {
            return _iceD_channelRemoved(in, current);
        }
        case 2:
        {
            return _iceD_channelStateChanged(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_userConnected(in, current);
        }
        case 8:
        {
            return _iceD_userDisconnected(in, current);
        }
        case 9:
        {
            return _iceD_userStateChanged(in, current);
        }
        case 10:
        {
            return _iceD_userTextMessage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Murmur::ServerCallback::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ServerCallback, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Murmur::ServerCallback::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerCallback, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Murmur::_icePatchObjectPtr(ServerCallbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ServerCallbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ServerCallback::ice_staticId(), v);
    }
}
/// \endcond

Murmur::ServerContextCallback::~ServerContextCallback()
{
}

/// \cond INTERNAL
::Ice::Object* Murmur::upCast(ServerContextCallback* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Murmur_ServerContextCallback_ids[2] =
{
    "::Ice::Object",
    "::Murmur::ServerContextCallback"
};

}

bool
Murmur::ServerContextCallback::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_ServerContextCallback_ids, iceC_Murmur_ServerContextCallback_ids + 2, s);
}

::std::vector< ::std::string>
Murmur::ServerContextCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Murmur_ServerContextCallback_ids[0], &iceC_Murmur_ServerContextCallback_ids[2]);
}

const ::std::string&
Murmur::ServerContextCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::ServerContextCallback::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Murmur::ServerContextCallback";
    return typeId;
#else
    return iceC_Murmur_ServerContextCallback_ids[1];
#endif
}

/// \cond INTERNAL
bool
Murmur::ServerContextCallback::_iceD_contextAction(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_action;
    User iceP_usr;
    ::Ice::Int iceP_session;
    ::Ice::Int iceP_channelid;
    istr->read(iceP_action);
    istr->read(iceP_usr);
    istr->read(iceP_session);
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->contextAction(iceP_action, iceP_usr, iceP_session, iceP_channelid, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Murmur_ServerContextCallback_all[] =
{
    "contextAction",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Murmur::ServerContextCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_ServerContextCallback_all, iceC_Murmur_ServerContextCallback_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_ServerContextCallback_all)
    {
        case 0:
        {
            return _iceD_contextAction(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Murmur::ServerContextCallback::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ServerContextCallback, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Murmur::ServerContextCallback::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerContextCallback, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Murmur::_icePatchObjectPtr(ServerContextCallbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ServerContextCallbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ServerContextCallback::ice_staticId(), v);
    }
}
/// \endcond

Murmur::ServerAuthenticator::~ServerAuthenticator()
{
}

/// \cond INTERNAL
::Ice::Object* Murmur::upCast(ServerAuthenticator* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Murmur_ServerAuthenticator_ids[2] =
{
    "::Ice::Object",
    "::Murmur::ServerAuthenticator"
};

}

bool
Murmur::ServerAuthenticator::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_ServerAuthenticator_ids, iceC_Murmur_ServerAuthenticator_ids + 2, s);
}

::std::vector< ::std::string>
Murmur::ServerAuthenticator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Murmur_ServerAuthenticator_ids[0], &iceC_Murmur_ServerAuthenticator_ids[2]);
}

const ::std::string&
Murmur::ServerAuthenticator::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::ServerAuthenticator::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Murmur::ServerAuthenticator";
    return typeId;
#else
    return iceC_Murmur_ServerAuthenticator_ids[1];
#endif
}

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceD_authenticate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_pw;
    CertificateList iceP_certificates;
    ::std::string iceP_certhash;
    bool iceP_certstrong;
    istr->read(iceP_name);
    istr->read(iceP_pw);
    istr->read(iceP_certificates);
    istr->read(iceP_certhash);
    istr->read(iceP_certstrong);
    inS.endReadParams();
    ::std::string iceP_newname;
    GroupNameList iceP_groups;
    ::Ice::Int ret = this->authenticate(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong, iceP_newname, iceP_groups, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_newname);
    ostr->write(iceP_groups);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceD_getInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    UserInfoMap iceP_info;
    bool ret = this->getInfo(iceP_id, iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_info);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceD_nameToId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->read(iceP_name);
    inS.endReadParams();
    ::Ice::Int ret = this->nameToId(iceP_name, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceD_idToName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ::std::string ret = this->idToName(iceP_id, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceD_idToTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    Texture ret = this->idToTexture(iceP_id, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Murmur_ServerAuthenticator_all[] =
{
    "authenticate",
    "getInfo",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "idToName",
    "idToTexture",
    "nameToId"
};

}

/// \cond INTERNAL
bool
Murmur::ServerAuthenticator::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_ServerAuthenticator_all, iceC_Murmur_ServerAuthenticator_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_ServerAuthenticator_all)
    {
        case 0:
        {
            return _iceD_authenticate(in, current);
        }
        case 1:
        {
            return _iceD_getInfo(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        case 6:
        {
            return _iceD_idToName(in, current);
        }
        case 7:
        {
            return _iceD_idToTexture(in, current);
        }
        case 8:
        {
            return _iceD_nameToId(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Murmur::ServerAuthenticator::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ServerAuthenticator, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Murmur::ServerAuthenticator::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerAuthenticator, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Murmur::_icePatchObjectPtr(ServerAuthenticatorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ServerAuthenticatorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ServerAuthenticator::ice_staticId(), v);
    }
}
/// \endcond

Murmur::ServerUpdatingAuthenticator::~ServerUpdatingAuthenticator()
{
}

/// \cond INTERNAL
::Ice::Object* Murmur::upCast(ServerUpdatingAuthenticator* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_ids[3] =
{
    "::Ice::Object",
    "::Murmur::ServerAuthenticator",
    "::Murmur::ServerUpdatingAuthenticator"
};

}

bool
Murmur::ServerUpdatingAuthenticator::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_ServerUpdatingAuthenticator_ids, iceC_Murmur_ServerUpdatingAuthenticator_ids + 3, s);
}

::std::vector< ::std::string>
Murmur::ServerUpdatingAuthenticator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Murmur_ServerUpdatingAuthenticator_ids[0], &iceC_Murmur_ServerUpdatingAuthenticator_ids[3]);
}

const ::std::string&
Murmur::ServerUpdatingAuthenticator::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::ServerUpdatingAuthenticator::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Murmur::ServerUpdatingAuthenticator";
    return typeId;
#else
    return iceC_Murmur_ServerUpdatingAuthenticator_ids[2];
#endif
}

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceD_registerUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    UserInfoMap iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    ::Ice::Int ret = this->registerUser(iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceD_unregisterUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ::Ice::Int ret = this->unregisterUser(iceP_id, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceD_getRegisteredUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_filter;
    istr->read(iceP_filter);
    inS.endReadParams();
    NameMap ret = this->getRegisteredUsers(iceP_filter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceD_setInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    UserInfoMap iceP_info;
    istr->read(iceP_id);
    istr->read(iceP_info);
    inS.endReadParams();
    ::Ice::Int ret = this->setInfo(iceP_id, iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceD_setTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    Texture iceP_tex;
    istr->read(iceP_id);
    istr->read(iceP_tex);
    inS.endReadParams();
    ::Ice::Int ret = this->setTexture(iceP_id, iceP_tex, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Murmur_ServerUpdatingAuthenticator_all[] =
{
    "authenticate",
    "getInfo",
    "getRegisteredUsers",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "idToName",
    "idToTexture",
    "nameToId",
    "registerUser",
    "setInfo",
    "setTexture",
    "unregisterUser"
};

}

/// \cond INTERNAL
bool
Murmur::ServerUpdatingAuthenticator::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_ServerUpdatingAuthenticator_all, iceC_Murmur_ServerUpdatingAuthenticator_all + 14, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_ServerUpdatingAuthenticator_all)
    {
        case 0:
        {
            return _iceD_authenticate(in, current);
        }
        case 1:
        {
            return _iceD_getInfo(in, current);
        }
        case 2:
        {
            return _iceD_getRegisteredUsers(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_idToName(in, current);
        }
        case 8:
        {
            return _iceD_idToTexture(in, current);
        }
        case 9:
        {
            return _iceD_nameToId(in, current);
        }
        case 10:
        {
            return _iceD_registerUser(in, current);
        }
        case 11:
        {
            return _iceD_setInfo(in, current);
        }
        case 12:
        {
            return _iceD_setTexture(in, current);
        }
        case 13:
        {
            return _iceD_unregisterUser(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Murmur::ServerUpdatingAuthenticator::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ServerUpdatingAuthenticator, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Murmur::ServerUpdatingAuthenticator::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerUpdatingAuthenticator, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Murmur::_icePatchObjectPtr(ServerUpdatingAuthenticatorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ServerUpdatingAuthenticatorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ServerUpdatingAuthenticator::ice_staticId(), v);
    }
}
/// \endcond

Murmur::Server::~Server()
{
}

/// \cond INTERNAL
::Ice::Object* Murmur::upCast(Server* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Murmur_Server_ids[2] =
{
    "::Ice::Object",
    "::Murmur::Server"
};

}

bool
Murmur::Server::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_Server_ids, iceC_Murmur_Server_ids + 2, s);
}

::std::vector< ::std::string>
Murmur::Server::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Murmur_Server_ids[0], &iceC_Murmur_Server_ids[2]);
}

const ::std::string&
Murmur::Server::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::Server::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Murmur::Server";
    return typeId;
#else
    return iceC_Murmur_Server_ids[1];
#endif
}

/// \cond INTERNAL
bool
Murmur::Server::_iceD_isRunning(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->isRunning_async(new IceAsync::Murmur::AMD_Server_isRunning(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_start(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->start_async(new IceAsync::Murmur::AMD_Server_start(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_stop(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->stop_async(new IceAsync::Murmur::AMD_Server_stop(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_delete(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->delete_async(new IceAsync::Murmur::AMD_Server_delete(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_id(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->id_async(new IceAsync::Murmur::AMD_Server_id(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_addCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerCallbackPrx iceP_cb;
    istr->read(iceP_cb);
    inS.endReadParams();
    this->addCallback_async(new IceAsync::Murmur::AMD_Server_addCallback(inS), iceP_cb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_removeCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerCallbackPrx iceP_cb;
    istr->read(iceP_cb);
    inS.endReadParams();
    this->removeCallback_async(new IceAsync::Murmur::AMD_Server_removeCallback(inS), iceP_cb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setAuthenticator(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerAuthenticatorPrx iceP_auth;
    istr->read(iceP_auth);
    inS.endReadParams();
    this->setAuthenticator_async(new IceAsync::Murmur::AMD_Server_setAuthenticator(inS), iceP_auth, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_key;
    istr->read(iceP_key);
    inS.endReadParams();
    this->getConf_async(new IceAsync::Murmur::AMD_Server_getConf(inS), iceP_key, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getAllConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getAllConf_async(new IceAsync::Murmur::AMD_Server_getAllConf(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_key;
    ::std::string iceP_value;
    istr->read(iceP_key);
    istr->read(iceP_value);
    inS.endReadParams();
    this->setConf_async(new IceAsync::Murmur::AMD_Server_setConf(inS), iceP_key, iceP_value, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setSuperuserPassword(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_pw;
    istr->read(iceP_pw);
    inS.endReadParams();
    this->setSuperuserPassword_async(new IceAsync::Murmur::AMD_Server_setSuperuserPassword(inS), iceP_pw, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getLog(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_first;
    ::Ice::Int iceP_last;
    istr->read(iceP_first);
    istr->read(iceP_last);
    inS.endReadParams();
    this->getLog_async(new IceAsync::Murmur::AMD_Server_getLog(inS), iceP_first, iceP_last, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getLogLen(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getLogLen_async(new IceAsync::Murmur::AMD_Server_getLogLen(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getUsers_async(new IceAsync::Murmur::AMD_Server_getUsers(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getChannels(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getChannels_async(new IceAsync::Murmur::AMD_Server_getChannels(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getCertificateList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    istr->read(iceP_session);
    inS.endReadParams();
    this->getCertificateList_async(new IceAsync::Murmur::AMD_Server_getCertificateList(inS), iceP_session, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getTree(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getTree_async(new IceAsync::Murmur::AMD_Server_getTree(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getBans(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getBans_async(new IceAsync::Murmur::AMD_Server_getBans(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setBans(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BanList iceP_bans;
    istr->read(iceP_bans);
    inS.endReadParams();
    this->setBans_async(new IceAsync::Murmur::AMD_Server_setBans(inS), iceP_bans, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_kickUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::std::string iceP_reason;
    istr->read(iceP_session);
    istr->read(iceP_reason);
    inS.endReadParams();
    this->kickUser_async(new IceAsync::Murmur::AMD_Server_kickUser(inS), iceP_session, iceP_reason, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    istr->read(iceP_session);
    inS.endReadParams();
    this->getState_async(new IceAsync::Murmur::AMD_Server_getState(inS), iceP_session, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    User iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->setState_async(new IceAsync::Murmur::AMD_Server_setState(inS), iceP_state, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_sendMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::std::string iceP_text;
    istr->read(iceP_session);
    istr->read(iceP_text);
    inS.endReadParams();
    this->sendMessage_async(new IceAsync::Murmur::AMD_Server_sendMessage(inS), iceP_session, iceP_text, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_hasPermission(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::Ice::Int iceP_channelid;
    ::Ice::Int iceP_perm;
    istr->read(iceP_session);
    istr->read(iceP_channelid);
    istr->read(iceP_perm);
    inS.endReadParams();
    this->hasPermission_async(new IceAsync::Murmur::AMD_Server_hasPermission(inS), iceP_session, iceP_channelid, iceP_perm, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_effectivePermissions(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::Ice::Int iceP_channelid;
    istr->read(iceP_session);
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->effectivePermissions_async(new IceAsync::Murmur::AMD_Server_effectivePermissions(inS), iceP_session, iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_addContextCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::std::string iceP_action;
    ::std::string iceP_text;
    ServerContextCallbackPrx iceP_cb;
    ::Ice::Int iceP_ctx;
    istr->read(iceP_session);
    istr->read(iceP_action);
    istr->read(iceP_text);
    istr->read(iceP_cb);
    istr->read(iceP_ctx);
    inS.endReadParams();
    this->addContextCallback_async(new IceAsync::Murmur::AMD_Server_addContextCallback(inS), iceP_session, iceP_action, iceP_text, iceP_cb, iceP_ctx, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_removeContextCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerContextCallbackPrx iceP_cb;
    istr->read(iceP_cb);
    inS.endReadParams();
    this->removeContextCallback_async(new IceAsync::Murmur::AMD_Server_removeContextCallback(inS), iceP_cb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getChannelState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->getChannelState_async(new IceAsync::Murmur::AMD_Server_getChannelState(inS), iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setChannelState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Channel iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->setChannelState_async(new IceAsync::Murmur::AMD_Server_setChannelState(inS), iceP_state, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_removeChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->removeChannel_async(new IceAsync::Murmur::AMD_Server_removeChannel(inS), iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_addChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::Ice::Int iceP_parent;
    istr->read(iceP_name);
    istr->read(iceP_parent);
    inS.endReadParams();
    this->addChannel_async(new IceAsync::Murmur::AMD_Server_addChannel(inS), iceP_name, iceP_parent, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_sendMessageChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    bool iceP_tree;
    ::std::string iceP_text;
    istr->read(iceP_channelid);
    istr->read(iceP_tree);
    istr->read(iceP_text);
    inS.endReadParams();
    this->sendMessageChannel_async(new IceAsync::Murmur::AMD_Server_sendMessageChannel(inS), iceP_channelid, iceP_tree, iceP_text, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getACL(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->getACL_async(new IceAsync::Murmur::AMD_Server_getACL(inS), iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setACL(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    ACLList iceP_acls;
    GroupList iceP_groups;
    bool iceP_inherit;
    istr->read(iceP_channelid);
    istr->read(iceP_acls);
    istr->read(iceP_groups);
    istr->read(iceP_inherit);
    inS.endReadParams();
    this->setACL_async(new IceAsync::Murmur::AMD_Server_setACL(inS), iceP_channelid, iceP_acls, iceP_groups, iceP_inherit, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_addUserToGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    ::Ice::Int iceP_session;
    ::std::string iceP_group;
    istr->read(iceP_channelid);
    istr->read(iceP_session);
    istr->read(iceP_group);
    inS.endReadParams();
    this->addUserToGroup_async(new IceAsync::Murmur::AMD_Server_addUserToGroup(inS), iceP_channelid, iceP_session, iceP_group, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_removeUserFromGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    ::Ice::Int iceP_session;
    ::std::string iceP_group;
    istr->read(iceP_channelid);
    istr->read(iceP_session);
    istr->read(iceP_group);
    inS.endReadParams();
    this->removeUserFromGroup_async(new IceAsync::Murmur::AMD_Server_removeUserFromGroup(inS), iceP_channelid, iceP_session, iceP_group, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_redirectWhisperGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::std::string iceP_source;
    ::std::string iceP_target;
    istr->read(iceP_session);
    istr->read(iceP_source);
    istr->read(iceP_target);
    inS.endReadParams();
    this->redirectWhisperGroup_async(new IceAsync::Murmur::AMD_Server_redirectWhisperGroup(inS), iceP_session, iceP_source, iceP_target, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getUserNames(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    IdList iceP_ids;
    istr->read(iceP_ids);
    inS.endReadParams();
    this->getUserNames_async(new IceAsync::Murmur::AMD_Server_getUserNames(inS), iceP_ids, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getUserIds(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    NameList iceP_names;
    istr->read(iceP_names);
    inS.endReadParams();
    this->getUserIds_async(new IceAsync::Murmur::AMD_Server_getUserIds(inS), iceP_names, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_registerUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    UserInfoMap iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    this->registerUser_async(new IceAsync::Murmur::AMD_Server_registerUser(inS), iceP_info, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_unregisterUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    istr->read(iceP_userid);
    inS.endReadParams();
    this->unregisterUser_async(new IceAsync::Murmur::AMD_Server_unregisterUser(inS), iceP_userid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_updateRegistration(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    UserInfoMap iceP_info;
    istr->read(iceP_userid);
    istr->read(iceP_info);
    inS.endReadParams();
    this->updateRegistration_async(new IceAsync::Murmur::AMD_Server_updateRegistration(inS), iceP_userid, iceP_info, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getRegistration(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    istr->read(iceP_userid);
    inS.endReadParams();
    this->getRegistration_async(new IceAsync::Murmur::AMD_Server_getRegistration(inS), iceP_userid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getRegisteredUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_filter;
    istr->read(iceP_filter);
    inS.endReadParams();
    this->getRegisteredUsers_async(new IceAsync::Murmur::AMD_Server_getRegisteredUsers(inS), iceP_filter, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_verifyPassword(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_pw;
    istr->read(iceP_name);
    istr->read(iceP_pw);
    inS.endReadParams();
    this->verifyPassword_async(new IceAsync::Murmur::AMD_Server_verifyPassword(inS), iceP_name, iceP_pw, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    istr->read(iceP_userid);
    inS.endReadParams();
    this->getTexture_async(new IceAsync::Murmur::AMD_Server_getTexture(inS), iceP_userid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_setTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    Texture iceP_tex;
    istr->read(iceP_userid);
    istr->read(iceP_tex);
    inS.endReadParams();
    this->setTexture_async(new IceAsync::Murmur::AMD_Server_setTexture(inS), iceP_userid, iceP_tex, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getUptime(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getUptime_async(new IceAsync::Murmur::AMD_Server_getUptime(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_updateCertificate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_certificate;
    ::std::string iceP_privateKey;
    ::std::string iceP_passphrase;
    istr->read(iceP_certificate);
    istr->read(iceP_privateKey);
    istr->read(iceP_passphrase);
    inS.endReadParams();
    this->updateCertificate_async(new IceAsync::Murmur::AMD_Server_updateCertificate(inS), iceP_certificate, iceP_privateKey, iceP_passphrase, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_startListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    ::Ice::Int iceP_channelid;
    istr->read(iceP_userid);
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->startListening_async(new IceAsync::Murmur::AMD_Server_startListening(inS), iceP_userid, iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_stopListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    ::Ice::Int iceP_channelid;
    istr->read(iceP_userid);
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->stopListening_async(new IceAsync::Murmur::AMD_Server_stopListening(inS), iceP_userid, iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_isListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    ::Ice::Int iceP_channelid;
    istr->read(iceP_userid);
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->isListening_async(new IceAsync::Murmur::AMD_Server_isListening(inS), iceP_userid, iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getListeningChannels(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    istr->read(iceP_userid);
    inS.endReadParams();
    this->getListeningChannels_async(new IceAsync::Murmur::AMD_Server_getListeningChannels(inS), iceP_userid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_getListeningUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->getListeningUsers_async(new IceAsync::Murmur::AMD_Server_getListeningUsers(inS), iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Server::_iceD_sendWelcomeMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    IdList iceP_receiverUserIDs;
    istr->read(iceP_receiverUserIDs);
    inS.endReadParams();
    this->sendWelcomeMessage_async(new IceAsync::Murmur::AMD_Server_sendWelcomeMessage(inS), iceP_receiverUserIDs, current);
    return false;
}
/// \endcond

namespace
{
const ::std::string iceC_Murmur_Server_all[] =
{
    "addCallback",
    "addChannel",
    "addContextCallback",
    "addUserToGroup",
    "delete",
    "effectivePermissions",
    "getACL",
    "getAllConf",
    "getBans",
    "getCertificateList",
    "getChannelState",
    "getChannels",
    "getConf",
    "getListeningChannels",
    "getListeningUsers",
    "getLog",
    "getLogLen",
    "getRegisteredUsers",
    "getRegistration",
    "getState",
    "getTexture",
    "getTree",
    "getUptime",
    "getUserIds",
    "getUserNames",
    "getUsers",
    "hasPermission",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "id",
    "isListening",
    "isRunning",
    "kickUser",
    "redirectWhisperGroup",
    "registerUser",
    "removeCallback",
    "removeChannel",
    "removeContextCallback",
    "removeUserFromGroup",
    "sendMessage",
    "sendMessageChannel",
    "sendWelcomeMessage",
    "setACL",
    "setAuthenticator",
    "setBans",
    "setChannelState",
    "setConf",
    "setState",
    "setSuperuserPassword",
    "setTexture",
    "start",
    "startListening",
    "stop",
    "stopListening",
    "unregisterUser",
    "updateCertificate",
    "updateRegistration",
    "verifyPassword"
};

}

/// \cond INTERNAL
bool
Murmur::Server::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_Server_all, iceC_Murmur_Server_all + 60, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_Server_all)
    {
        case 0:
        {
            return _iceD_addCallback(in, current);
        }
        case 1:
        {
            return _iceD_addChannel(in, current);
        }
        case 2:
        {
            return _iceD_addContextCallback(in, current);
        }
        case 3:
        {
            return _iceD_addUserToGroup(in, current);
        }
        case 4:
        {
            return _iceD_delete(in, current);
        }
        case 5:
        {
            return _iceD_effectivePermissions(in, current);
        }
        case 6:
        {
            return _iceD_getACL(in, current);
        }
        case 7:
        {
            return _iceD_getAllConf(in, current);
        }
        case 8:
        {
            return _iceD_getBans(in, current);
        }
        case 9:
        {
            return _iceD_getCertificateList(in, current);
        }
        case 10:
        {
            return _iceD_getChannelState(in, current);
        }
        case 11:
        {
            return _iceD_getChannels(in, current);
        }
        case 12:
        {
            return _iceD_getConf(in, current);
        }
        case 13:
        {
            return _iceD_getListeningChannels(in, current);
        }
        case 14:
        {
            return _iceD_getListeningUsers(in, current);
        }
        case 15:
        {
            return _iceD_getLog(in, current);
        }
        case 16:
        {
            return _iceD_getLogLen(in, current);
        }
        case 17:
        {
            return _iceD_getRegisteredUsers(in, current);
        }
        case 18:
        {
            return _iceD_getRegistration(in, current);
        }
        case 19:
        {
            return _iceD_getState(in, current);
        }
        case 20:
        {
            return _iceD_getTexture(in, current);
        }
        case 21:
        {
            return _iceD_getTree(in, current);
        }
        case 22:
        {
            return _iceD_getUptime(in, current);
        }
        case 23:
        {
            return _iceD_getUserIds(in, current);
        }
        case 24:
        {
            return _iceD_getUserNames(in, current);
        }
        case 25:
        {
            return _iceD_getUsers(in, current);
        }
        case 26:
        {
            return _iceD_hasPermission(in, current);
        }
        case 27:
        {
            return _iceD_ice_id(in, current);
        }
        case 28:
        {
            return _iceD_ice_ids(in, current);
        }
        case 29:
        {
            return _iceD_ice_isA(in, current);
        }
        case 30:
        {
            return _iceD_ice_ping(in, current);
        }
        case 31:
        {
            return _iceD_id(in, current);
        }
        case 32:
        {
            return _iceD_isListening(in, current);
        }
        case 33:
        {
            return _iceD_isRunning(in, current);
        }
        case 34:
        {
            return _iceD_kickUser(in, current);
        }
        case 35:
        {
            return _iceD_redirectWhisperGroup(in, current);
        }
        case 36:
        {
            return _iceD_registerUser(in, current);
        }
        case 37:
        {
            return _iceD_removeCallback(in, current);
        }
        case 38:
        {
            return _iceD_removeChannel(in, current);
        }
        case 39:
        {
            return _iceD_removeContextCallback(in, current);
        }
        case 40:
        {
            return _iceD_removeUserFromGroup(in, current);
        }
        case 41:
        {
            return _iceD_sendMessage(in, current);
        }
        case 42:
        {
            return _iceD_sendMessageChannel(in, current);
        }
        case 43:
        {
            return _iceD_sendWelcomeMessage(in, current);
        }
        case 44:
        {
            return _iceD_setACL(in, current);
        }
        case 45:
        {
            return _iceD_setAuthenticator(in, current);
        }
        case 46:
        {
            return _iceD_setBans(in, current);
        }
        case 47:
        {
            return _iceD_setChannelState(in, current);
        }
        case 48:
        {
            return _iceD_setConf(in, current);
        }
        case 49:
        {
            return _iceD_setState(in, current);
        }
        case 50:
        {
            return _iceD_setSuperuserPassword(in, current);
        }
        case 51:
        {
            return _iceD_setTexture(in, current);
        }
        case 52:
        {
            return _iceD_start(in, current);
        }
        case 53:
        {
            return _iceD_startListening(in, current);
        }
        case 54:
        {
            return _iceD_stop(in, current);
        }
        case 55:
        {
            return _iceD_stopListening(in, current);
        }
        case 56:
        {
            return _iceD_unregisterUser(in, current);
        }
        case 57:
        {
            return _iceD_updateCertificate(in, current);
        }
        case 58:
        {
            return _iceD_updateRegistration(in, current);
        }
        case 59:
        {
            return _iceD_verifyPassword(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Murmur::Server::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Server, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Murmur::Server::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Server, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Murmur::_icePatchObjectPtr(ServerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ServerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Server::ice_staticId(), v);
    }
}
/// \endcond

Murmur::MetaCallback::~MetaCallback()
{
}

/// \cond INTERNAL
::Ice::Object* Murmur::upCast(MetaCallback* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Murmur_MetaCallback_ids[2] =
{
    "::Ice::Object",
    "::Murmur::MetaCallback"
};

}

bool
Murmur::MetaCallback::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_MetaCallback_ids, iceC_Murmur_MetaCallback_ids + 2, s);
}

::std::vector< ::std::string>
Murmur::MetaCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Murmur_MetaCallback_ids[0], &iceC_Murmur_MetaCallback_ids[2]);
}

const ::std::string&
Murmur::MetaCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::MetaCallback::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Murmur::MetaCallback";
    return typeId;
#else
    return iceC_Murmur_MetaCallback_ids[1];
#endif
}

/// \cond INTERNAL
bool
Murmur::MetaCallback::_iceD_started(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerPrx iceP_srv;
    istr->read(iceP_srv);
    inS.endReadParams();
    this->started(iceP_srv, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::MetaCallback::_iceD_stopped(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerPrx iceP_srv;
    istr->read(iceP_srv);
    inS.endReadParams();
    this->stopped(iceP_srv, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Murmur_MetaCallback_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "started",
    "stopped"
};

}

/// \cond INTERNAL
bool
Murmur::MetaCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_MetaCallback_all, iceC_Murmur_MetaCallback_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_MetaCallback_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_started(in, current);
        }
        case 5:
        {
            return _iceD_stopped(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Murmur::MetaCallback::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< MetaCallback, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Murmur::MetaCallback::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MetaCallback, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Murmur::_icePatchObjectPtr(MetaCallbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MetaCallbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(MetaCallback::ice_staticId(), v);
    }
}
/// \endcond

Murmur::Meta::~Meta()
{
}

/// \cond INTERNAL
::Ice::Object* Murmur::upCast(Meta* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Murmur_Meta_ids[2] =
{
    "::Ice::Object",
    "::Murmur::Meta"
};

}

bool
Murmur::Meta::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Murmur_Meta_ids, iceC_Murmur_Meta_ids + 2, s);
}

::std::vector< ::std::string>
Murmur::Meta::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Murmur_Meta_ids[0], &iceC_Murmur_Meta_ids[2]);
}

const ::std::string&
Murmur::Meta::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Murmur::Meta::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Murmur::Meta";
    return typeId;
#else
    return iceC_Murmur_Meta_ids[1];
#endif
}

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    this->getServer_async(new IceAsync::Murmur::AMD_Meta_getServer(inS), iceP_id, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_newServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->newServer_async(new IceAsync::Murmur::AMD_Meta_newServer(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getBootedServers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getBootedServers_async(new IceAsync::Murmur::AMD_Meta_getBootedServers(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getAllServers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getAllServers_async(new IceAsync::Murmur::AMD_Meta_getAllServers(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getDefaultConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getDefaultConf_async(new IceAsync::Murmur::AMD_Meta_getDefaultConf(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getVersion_async(new IceAsync::Murmur::AMD_Meta_getVersion(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_addCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MetaCallbackPrx iceP_cb;
    istr->read(iceP_cb);
    inS.endReadParams();
    this->addCallback_async(new IceAsync::Murmur::AMD_Meta_addCallback(inS), iceP_cb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_removeCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MetaCallbackPrx iceP_cb;
    istr->read(iceP_cb);
    inS.endReadParams();
    this->removeCallback_async(new IceAsync::Murmur::AMD_Meta_removeCallback(inS), iceP_cb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getUptime(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getUptime_async(new IceAsync::Murmur::AMD_Meta_getUptime(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getSlice(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getSlice_async(new IceAsync::Murmur::AMD_Meta_getSlice(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Murmur::Meta::_iceD_getSliceChecksums(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getSliceChecksums_async(new IceAsync::Murmur::AMD_Meta_getSliceChecksums(inS), current);
    return false;
}
/// \endcond

namespace
{
const ::std::string iceC_Murmur_Meta_all[] =
{
    "addCallback",
    "getAllServers",
    "getBootedServers",
    "getDefaultConf",
    "getServer",
    "getSlice",
    "getSliceChecksums",
    "getUptime",
    "getVersion",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "newServer",
    "removeCallback"
};

}

/// \cond INTERNAL
bool
Murmur::Meta::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Murmur_Meta_all, iceC_Murmur_Meta_all + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Murmur_Meta_all)
    {
        case 0:
        {
            return _iceD_addCallback(in, current);
        }
        case 1:
        {
            return _iceD_getAllServers(in, current);
        }
        case 2:
        {
            return _iceD_getBootedServers(in, current);
        }
        case 3:
        {
            return _iceD_getDefaultConf(in, current);
        }
        case 4:
        {
            return _iceD_getServer(in, current);
        }
        case 5:
        {
            return _iceD_getSlice(in, current);
        }
        case 6:
        {
            return _iceD_getSliceChecksums(in, current);
        }
        case 7:
        {
            return _iceD_getUptime(in, current);
        }
        case 8:
        {
            return _iceD_getVersion(in, current);
        }
        case 9:
        {
            return _iceD_ice_id(in, current);
        }
        case 10:
        {
            return _iceD_ice_ids(in, current);
        }
        case 11:
        {
            return _iceD_ice_isA(in, current);
        }
        case 12:
        {
            return _iceD_ice_ping(in, current);
        }
        case 13:
        {
            return _iceD_newServer(in, current);
        }
        case 14:
        {
            return _iceD_removeCallback(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Murmur::Meta::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Meta, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Murmur::Meta::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Meta, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Murmur::_icePatchObjectPtr(MetaPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MetaPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Meta::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

namespace
{

const char* iceSliceChecksums[] =
{
    "::Murmur::ACL", "157797fb27cda83faec7e5374284e275",
    "::Murmur::ACLList", "c0d51a6dadd205ea4ceed3ab8605e",
    "::Murmur::Ban", "77c83f17e3b1603f5d35b47fa33870",
    "::Murmur::BanList", "0c7df186822caffee1c2391a82de0a8",
    "::Murmur::CertificateDer", "bda5350e8ec40eef1cae7c2b3c616cf",
    "::Murmur::CertificateList", "bb8d3e415f174d82a74a3abebeadc0",
    "::Murmur::Channel", "3d7546228b98475e03e4bd2eef7042",
    "::Murmur::ChannelInfo", "1e1c915adb3475dd6aa6943aff139d7c",
    "::Murmur::ChannelList", "b6a00a1063ca328741442333853ac",
    "::Murmur::ChannelMap", "c680d84f229348aeac44fceda7a02cc8",
    "::Murmur::ConfigMap", "a959102c70f61ff099b044a145ba2a",
    "::Murmur::ContextChannel", "d031ddb65dbaea316b6718ffa867852",
    "::Murmur::ContextServer", "36637f606caa3dfe7a88816f3d1d4b4",
    "::Murmur::ContextUser", "928e6ca841dc5467d671cc7e94a47b1",
    "::Murmur::Group", "351a3b2b4d272047beca8770793874b",
    "::Murmur::GroupList", "cbca3d925b7b06eb1d0ca15379977e8",
    "::Murmur::GroupNameList", "3129349326861d482a77548514a44ea9",
    "::Murmur::IdList", "ee9f8c35179c12487ff62e359b7f267b",
    "::Murmur::IdMap", "36f07840567acf5a1a182b80cc4ec4c8",
    "::Murmur::IntList", "6f1c32278d7993b8e7fcab62838cfa6",
    "::Murmur::InvalidCallbackException", "8f793feff89155d9b9b47cd11c283f",
    "::Murmur::InvalidChannelException", "551df6f38d8243dfc01b8ae610f0a41b",
    "::Murmur::InvalidInputDataException", "f28c685e6e2ccaa11687822d24d80ba",
    "::Murmur::InvalidSecretException", "2fb9069906614c74d6f54ffb7299723",
    "::Murmur::InvalidServerException", "8c23808992774379fd0deede158a24d",
    "::Murmur::InvalidSessionException", "411551c2f6abb9aa68b0dce4da1f2261",
    "::Murmur::InvalidTextureException", "c2f0fb931df3ceac9f3b231d90d1f66a",
    "::Murmur::InvalidUserException", "deaaf2325132ceebde9ba71eae8aae0",
    "::Murmur::LogEntry", "baf7375450f0cf5a4221ac1080297efb",
    "::Murmur::LogList", "816cdfe716397174d44069acd3309836",
    "::Murmur::Meta", "11f0c26da8d8ffb8135a7028ddfe43e",
    "::Murmur::MetaCallback", "8769511071e0b08b8dfc4b1ca1c352a",
    "::Murmur::MurmurException", "f14e757fac3ec91e3eb581beaf8d1af",
    "::Murmur::NameList", "492b93e2b12d2bd7f61f719a67b8623b",
    "::Murmur::NameMap", "8eb7985198a0add716b9462cbdd8c",
    "::Murmur::NestingLimitException", "f7a9a488daca3d97d689debc832c76",
    "::Murmur::NetAddress", "fe2a565d478baf1e5e2168ca4492d9d",
    "::Murmur::PermissionBan", "ac198d670d743c882937073eae3247",
    "::Murmur::PermissionEnter", "54fa28c949285c187f4df657b087b8",
    "::Murmur::PermissionKick", "15a8e0bcd0862dba4b5b72550f09aad",
    "::Murmur::PermissionLinkChannel", "992d2978f5eb8c5c5c8ec68aee4f890",
    "::Murmur::PermissionMakeChannel", "7cb412acce465d84c9a11bc5cd43e66",
    "::Murmur::PermissionMakeTempChannel", "beeec37912c744f855149ab30608344",
    "::Murmur::PermissionMove", "19f25e8a3ccabbbdf7316a675d6cc87",
    "::Murmur::PermissionMuteDeafen", "53c56b4bd8cf231a4090ef24ed893939",
    "::Murmur::PermissionRegister", "d0c4e13de6abc868b79cf01bb7d5c1ad",
    "::Murmur::PermissionRegisterSelf", "3a9718827e1cdc13b1fde4a724df8",
    "::Murmur::PermissionSpeak", "cfd814f27bac13db9c9a342a0512a4b",
    "::Murmur::PermissionTextMessage", "b5d36eeecdffc56a3a72854a1469145b",
    "::Murmur::PermissionTraverse", "37f12b9bb96c0d07a7c45e1bfef0fe",
    "::Murmur::PermissionWhisper", "dddf47c35e992f8cd868c4321f9bcb",
    "::Murmur::PermissionWrite", "a939b87d29f9fff8b2f957b3e4b121c0",
    "::Murmur::ResetUserContent", "144ba8653415acdee3d3f946a18058",
    "::Murmur::Server", "6ae1cdc268e435bab7cbab20a5697acb",
    "::Murmur::ServerAuthenticator", "53d631793acaba02db8a24971d9032",
    "::Murmur::ServerBootedException", "ddeb7c96e12425ac5fa5a6a94f956",
    "::Murmur::ServerCallback", "8963c15b917c6dac6ab1a7abdbd",
    "::Murmur::ServerContextCallback", "aa3c7926b1cea864d4a280e116ce42",
    "::Murmur::ServerFailureException", "1fe7854e87d2f446c8ff19f38043e821",
    "::Murmur::ServerList", "c4b0f170133f5681b162f8eff53fe",
    "::Murmur::ServerUpdatingAuthenticator", "ad94f3cb11cd39bf69ad81f879af45f",
    "::Murmur::TextMessage", "31d8456b13daf9ab43832a7b381f73b7",
    "::Murmur::Texture", "141dd3bb5aa45668e290153de4e8a23c",
    "::Murmur::Tree", "d22bc269c9dab07c1ff38be14e4bf89",
    "::Murmur::TreeList", "d7942bdad7624ea9e13a297b75fa7da",
    "::Murmur::User", "b0d23475ce2fc5fd59558ea55796946",
    "::Murmur::UserInfo", "3c1a3c8ac61325a80f23f21e5466294",
    "::Murmur::UserInfoMap", "422b99b6357d73912dfea65a794c41a6",
    "::Murmur::UserList", "629ef93051c372dd4ab85895fd9d311",
    "::Murmur::UserMap", "787e8028481a284f43687305c91473",
    "::Murmur::WriteOnlyException", "8aca8bfe9c995581fe3dc942c5a342b",
    0
};
const IceInternal::SliceChecksumInit iceSliceChecksumInit(iceSliceChecksums);

}

#endif
